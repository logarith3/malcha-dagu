This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/settings.local.json
.env.example
.gitignore
backend/config/__init__.py
backend/config/asgi.py
backend/config/celery.py
backend/config/middleware.py
backend/config/settings.py
backend/config/urls.py
backend/config/wsgi.py
backend/dagu/__init__.py
backend/dagu/admin.py
backend/dagu/apps.py
backend/dagu/authentication.py
backend/dagu/config.py
backend/dagu/exceptions.py
backend/dagu/filters.py
backend/dagu/migrations/__init__.py
backend/dagu/migrations/0001_initial.py
backend/dagu/migrations/0002_alter_instrument_image_url_alter_instrument_name_and_more.py
backend/dagu/migrations/0003_alter_useritem_source.py
backend/dagu/migrations/0004_useritem_extended_at_useritem_owner_id.py
backend/dagu/models.py
backend/dagu/serializers.py
backend/dagu/services.py
backend/dagu/services/__init__.py
backend/dagu/services/ai.py
backend/dagu/services/naver.py
backend/dagu/services/search.py
backend/dagu/services/utils.py
backend/dagu/tasks.py
backend/dagu/tests.py
backend/dagu/urls.py
backend/dagu/views.py
backend/db.sqlite3
backend/Dockerfile
backend/manage.py
backend/requirements.txt
backend/SEARCH_LOGIC.md
docker-compose.yml
frontend/.gitignore
frontend/Dockerfile
frontend/eslint.config.js
frontend/index.html
frontend/nginx.conf
frontend/package.json
frontend/public/vite.svg
frontend/README.md
frontend/src/App.css
frontend/src/App.tsx
frontend/src/assets/react.svg
frontend/src/components/ItemCard.tsx
frontend/src/components/MatchaBounceLoader.tsx
frontend/src/components/SearchBar.tsx
frontend/src/components/VSComparisonLayout.tsx
frontend/src/hooks/useAuth.ts
frontend/src/hooks/useSearch.ts
frontend/src/index.css
frontend/src/main.tsx
frontend/src/pages/HomePage.tsx
frontend/src/pages/SearchResultPage.tsx
frontend/src/services/api.ts
frontend/src/types/index.ts
frontend/tsconfig.app.json
frontend/tsconfig.json
frontend/tsconfig.node.json
frontend/vite.config.ts
run_server.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/dagu/migrations/0004_useritem_extended_at_useritem_owner_id.py">
# Generated by Django 5.2.8 on 2026-01-16 09:43

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('dagu', '0003_alter_useritem_source'),
    ]

    operations = [
        migrations.AddField(
            model_name='useritem',
            name='extended_at',
            field=models.DateTimeField(blank=True, null=True, verbose_name='연장 시점'),
        ),
        migrations.AddField(
            model_name='useritem',
            name='owner_id',
            field=models.IntegerField(blank=True, db_index=True, null=True, verbose_name='등록자 ID'),
        ),
    ]
</file>

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(xargs -I {} bash -c 'wc -l \"\"{}\"\" | awk \"\"{print \\\\$1 \\\\\"\" {} \\\\\"\"}\"\"')",
      "Bash(sort:*)",
      "Bash(python:*)",
      "Bash(npx tsc:*)"
    ]
  }
}
</file>

<file path=".gitignore">
.env
</file>

<file path="backend/config/__init__.py">
# This will make sure the app is always imported when
# Django starts so that shared_task will use this app.
from .celery import app as celery_app

__all__ = ('celery_app',)
</file>

<file path="backend/config/asgi.py">
"""
ASGI config for config project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_asgi_application()
</file>

<file path="backend/config/celery.py">
"""
Celery configuration for MALCHA-DAGU project.
"""

import os

from celery import Celery

# Set the default Django settings module
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

app = Celery('config')

# Load config from Django settings
app.config_from_object('django.conf:settings', namespace='CELERY')

# Auto-discover tasks from all installed apps
app.autodiscover_tasks()


@app.task(bind=True, ignore_result=True)
def debug_task(self):
    print(f'Request: {self.request!r}')
</file>

<file path="backend/config/middleware.py">
"""
Security middleware for MALCHA-DAGU.
Adds additional security headers to all responses.
"""

import logging

logger = logging.getLogger(__name__)


class SecurityHeadersMiddleware:
    """
    추가 보안 헤더를 모든 응답에 추가하는 미들웨어.

    추가되는 헤더:
    - X-Content-Type-Options: nosniff (MIME 타입 스니핑 방지)
    - X-Frame-Options: DENY (클릭재킹 방지)
    - Referrer-Policy: strict-origin-when-cross-origin
    - Permissions-Policy: 불필요한 브라우저 기능 비활성화
    - Cache-Control: API 응답 캐시 방지 (민감한 데이터)
    """

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        response = self.get_response(request)

        # MIME 타입 스니핑 방지
        response['X-Content-Type-Options'] = 'nosniff'

        # 클릭재킹 방지 (iframe 삽입 차단)
        response['X-Frame-Options'] = 'DENY'

        # Referrer 정책 (외부 사이트에 URL 노출 제한)
        response['Referrer-Policy'] = 'strict-origin-when-cross-origin'

        # Permissions-Policy (불필요한 브라우저 API 비활성화)
        response['Permissions-Policy'] = (
            "accelerometer=(), "
            "camera=(), "
            "geolocation=(), "
            "gyroscope=(), "
            "magnetometer=(), "
            "microphone=(), "
            "payment=(), "
            "usb=()"
        )

        # API 응답은 캐시하지 않음 (민감한 데이터 보호)
        if request.path.startswith('/api/'):
            response['Cache-Control'] = 'no-store, no-cache, must-revalidate, private'
            response['Pragma'] = 'no-cache'

        return response


class RequestLoggingMiddleware:
    """
    보안 모니터링을 위한 요청 로깅 미들웨어.

    로깅 항목:
    - 인증 실패 요청
    - 의심스러운 요청 패턴
    - Rate limit 근접 요청
    """

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        response = self.get_response(request)

        # 인증 실패 응답 로깅 (401, 403)
        if response.status_code in [401, 403]:
            client_ip = self._get_client_ip(request)
            logger.warning(
                f"Auth failure: {request.method} {request.path} "
                f"status={response.status_code} ip={client_ip} "
                f"user_agent={request.META.get('HTTP_USER_AGENT', 'unknown')[:100]}"
            )

        # Rate limit 응답 로깅 (429)
        if response.status_code == 429:
            client_ip = self._get_client_ip(request)
            logger.warning(
                f"Rate limit exceeded: {request.method} {request.path} "
                f"ip={client_ip}"
            )

        return response

    def _get_client_ip(self, request) -> str:
        """클라이언트 IP 추출 (프록시 고려)"""
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            return x_forwarded_for.split(',')[0].strip()
        return request.META.get('REMOTE_ADDR', 'unknown')
</file>

<file path="backend/config/urls.py">
"""
URL configuration for MALCHA-DAGU project.
"""
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('dagu.urls')),
]
</file>

<file path="backend/config/wsgi.py">
"""
WSGI config for config project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_wsgi_application()
</file>

<file path="backend/dagu/__init__.py">

</file>

<file path="backend/dagu/admin.py">
"""
Admin configuration for MALCHA-DAGU.
"""

from django.contrib import admin

from .models import Instrument, UserItem


@admin.register(Instrument)
class InstrumentAdmin(admin.ModelAdmin):
    list_display = ['brand', 'name', 'category', 'reference_price', 'created_at']
    list_filter = ['category', 'brand']
    search_fields = ['name', 'brand']
    ordering = ['brand', 'name']


@admin.register(UserItem)
class UserItemAdmin(admin.ModelAdmin):
    list_display = [
        'instrument', 'price', 'source', 'is_active', 
        'expired_at', 'click_count', 'created_at'
    ]
    list_filter = ['is_active', 'source', 'instrument__category']
    search_fields = ['instrument__name', 'instrument__brand', 'title']
    ordering = ['-created_at']
    readonly_fields = ['click_count', 'created_at', 'updated_at']
    
    def get_queryset(self, request):
        return super().get_queryset(request).select_related('instrument')
</file>

<file path="backend/dagu/apps.py">
from django.apps import AppConfig


class DaguConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'dagu'
</file>

<file path="backend/dagu/authentication.py">
"""
SSO JWT Cookie Authentication for MALCHA-DAGU.
Validates JWT tokens issued by Malcha (malchalab.com) from cookies.

Security Features:
- Issuer (iss) 검증: malchalab.com에서 발급된 토큰만 허용
- Audience (aud) 검증: dagu.malchalab.com이 수신자인 토큰만 허용
- Lazy User Sync: 유효한 토큰이면 Dagu DB에 자동 사용자 생성
- 상세 보안 로깅
"""

import logging
import time
from functools import lru_cache

from django.conf import settings
from django.contrib.auth import get_user_model
from django.core.cache import cache
from rest_framework_simplejwt.authentication import JWTAuthentication
from rest_framework_simplejwt.exceptions import InvalidToken, TokenError, AuthenticationFailed

logger = logging.getLogger(__name__)
User = get_user_model()

# 인증 실패 추적용 캐시 키 prefix
AUTH_FAIL_CACHE_PREFIX = 'sso_auth_fail:'
AUTH_FAIL_THRESHOLD = 10  # 10회 실패
AUTH_FAIL_WINDOW = 300  # 5분


class JWTCookieAuthentication(JWTAuthentication):
    """
    Malcha에서 발급한 JWT 쿠키를 읽어 인증하는 클래스.

    SSO 구조:
    - Malcha (malchalab.com): JWT 발급 (Auth Server)
    - Dagu (dagu.malchalab.com): JWT 검증 (Resource Server)

    보안 기능:
    - Issuer/Audience claim 검증 (settings에서 자동 처리)
    - 인증 실패 Rate Limiting (IP 기반)
    - Lazy User Sync (유효한 토큰만)
    - 상세 보안 로깅
    """

    def authenticate(self, request):
        """
        쿠키에서 JWT access token을 추출하여 검증.

        Returns:
            tuple: (user, validated_token) 인증 성공 시
            None: 쿠키에 토큰이 없을 때

        Raises:
            AuthenticationFailed: Rate limit 초과 시
        """
        # 설정에서 쿠키명 가져오기
        cookie_name = getattr(settings, 'SIMPLE_JWT', {}).get('AUTH_COOKIE', 'malcha-access-token')

        # 쿠키에서 access token 추출
        raw_token = request.COOKIES.get(cookie_name)

        if raw_token is None:
            return None

        # Rate Limiting 체크 (IP 기반)
        client_ip = self._get_client_ip(request)
        if self._is_rate_limited(client_ip):
            logger.warning(f"SSO rate limit exceeded for IP: {client_ip}")
            raise AuthenticationFailed('Too many authentication attempts. Please try again later.')

        try:
            # 토큰 검증 (서명, 만료, iss, aud 등 - SimpleJWT가 자동 처리)
            validated_token = self.get_validated_token(raw_token)

            # 추가 보안 검증
            self._validate_token_claims(validated_token)

            # 토큰에서 사용자 정보 추출 또는 생성
            user = self._get_or_create_user(validated_token)

            if user:
                # 인증 성공 시 실패 카운터 리셋
                self._reset_fail_count(client_ip)
                logger.info(f"SSO authentication successful: user_id={user.id}, ip={client_ip}")
                return user, validated_token
            else:
                self._record_auth_failure(client_ip, "user_creation_failed")
                return None

        except TokenError as e:
            self._record_auth_failure(client_ip, f"token_error: {e}")
            logger.warning(f"SSO token validation failed: {e} (ip={client_ip})")
            return None
        except AuthenticationFailed:
            raise  # Rate limit 에러는 그대로 전달
        except Exception as e:
            self._record_auth_failure(client_ip, f"unexpected_error: {e}")
            logger.error(f"SSO authentication error: {e} (ip={client_ip})")
            return None

    def _get_client_ip(self, request) -> str:
        """클라이언트 IP 추출 (프록시 고려)"""
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            return x_forwarded_for.split(',')[0].strip()
        return request.META.get('REMOTE_ADDR', 'unknown')

    def _is_rate_limited(self, client_ip: str) -> bool:
        """인증 실패 Rate Limiting 체크"""
        cache_key = f"{AUTH_FAIL_CACHE_PREFIX}{client_ip}"
        fail_count = cache.get(cache_key, 0)
        return fail_count >= AUTH_FAIL_THRESHOLD

    def _record_auth_failure(self, client_ip: str, reason: str):
        """인증 실패 기록"""
        cache_key = f"{AUTH_FAIL_CACHE_PREFIX}{client_ip}"
        fail_count = cache.get(cache_key, 0) + 1
        cache.set(cache_key, fail_count, AUTH_FAIL_WINDOW)
        logger.warning(f"SSO auth failure recorded: ip={client_ip}, count={fail_count}, reason={reason}")

    def _reset_fail_count(self, client_ip: str):
        """인증 성공 시 실패 카운터 리셋"""
        cache_key = f"{AUTH_FAIL_CACHE_PREFIX}{client_ip}"
        cache.delete(cache_key)

    def _validate_token_claims(self, validated_token):
        """
        추가 토큰 클레임 검증.
        SimpleJWT가 iss/aud는 자동 검증하므로 여기서는 추가 검증만 수행.
        """
        # token_type 검증 (access 토큰만 허용)
        token_type = validated_token.get('token_type')
        if token_type != 'access':
            raise TokenError(f"Invalid token type: {token_type}")

        # user_id 존재 여부 확인
        user_id = validated_token.get('user_id')
        if not user_id:
            raise TokenError("Missing user_id claim")

        # jti (JWT ID) 존재 여부 확인 (블랙리스트 체크용)
        jti = validated_token.get('jti')
        if not jti:
            logger.warning("Token missing jti claim - blacklist check unavailable")

    def _get_or_create_user(self, validated_token):
        """
        토큰에서 사용자 조회 또는 생성 (Lazy Sync).

        Malcha의 user_id를 사용하여 Dagu DB에서 조회.
        없으면 자동 생성.

        보안 고려사항:
        - user_id 타입 검증 (정수만 허용)
        - 생성 시 최소 권한만 부여
        - 상세 로깅
        """
        try:
            # 기본 방식으로 사용자 조회 시도
            return self.get_user(validated_token)
        except Exception:
            pass

        # 사용자가 없으면 토큰에서 정보 추출하여 생성
        try:
            user_id = validated_token.get('user_id')
            if not user_id:
                logger.warning("SSO token missing user_id claim")
                return None

            # user_id 타입 검증 (정수만 허용 - injection 방지)
            if not isinstance(user_id, int):
                try:
                    user_id = int(user_id)
                except (ValueError, TypeError):
                    logger.error(f"SSO invalid user_id type: {type(user_id)}")
                    return None

            # user_id 범위 검증 (음수 방지)
            if user_id <= 0:
                logger.error(f"SSO invalid user_id value: {user_id}")
                return None

            # Malcha user_id로 Dagu DB에 사용자 생성/조회
            user, created = User.objects.get_or_create(
                id=user_id,
                defaults={
                    'username': f'malcha_user_{user_id}',
                    'is_active': True,
                    # 보안: staff/superuser 권한 부여 안함
                    'is_staff': False,
                    'is_superuser': False,
                }
            )

            if created:
                logger.info(f"SSO: Created new user in Dagu DB (id={user_id})")
            else:
                logger.debug(f"SSO: Found existing user in Dagu DB (id={user_id})")

            return user

        except Exception as e:
            logger.error(f"SSO user sync failed: {e}")
            return None
</file>

<file path="backend/dagu/exceptions.py">
"""
Custom exception handling for MALCHA-DAGU API.
표준화된 에러 응답 형식 제공.
"""

import logging

from django.core.exceptions import PermissionDenied, ValidationError
from django.http import Http404
from rest_framework import status
from rest_framework.exceptions import APIException, Throttled
from rest_framework.response import Response
from rest_framework.views import exception_handler

logger = logging.getLogger(__name__)


def custom_exception_handler(exc, context):
    """
    DRF 전역 예외 핸들러.

    표준화된 에러 응답 형식:
    {
        "error": {
            "code": "ERROR_CODE",
            "message": "사용자 친화적 메시지",
            "detail": "상세 정보 (개발용)"
        }
    }
    """
    # 기본 DRF 예외 핸들러 호출
    response = exception_handler(exc, context)

    # 요청 정보 로깅
    request = context.get('request')
    view = context.get('view')
    view_name = view.__class__.__name__ if view else 'Unknown'

    if response is not None:
        # DRF 예외 처리됨
        error_response = format_error_response(exc, response)
        response.data = error_response

        # 로깅 (500 에러는 ERROR, 그 외는 WARNING)
        if response.status_code >= 500:
            logger.error(
                f"API Error [{response.status_code}] {view_name}: {exc}",
                extra={'request': request}
            )
        else:
            logger.warning(
                f"API Warning [{response.status_code}] {view_name}: {exc}",
                extra={'request': request}
            )

        return response

    # DRF에서 처리되지 않은 예외
    if isinstance(exc, Http404):
        return Response(
            format_error_response(exc, None, code='NOT_FOUND', message='요청한 리소스를 찾을 수 없습니다.'),
            status=status.HTTP_404_NOT_FOUND
        )

    if isinstance(exc, PermissionDenied):
        return Response(
            format_error_response(exc, None, code='PERMISSION_DENIED', message='권한이 없습니다.'),
            status=status.HTTP_403_FORBIDDEN
        )

    if isinstance(exc, ValidationError):
        return Response(
            format_error_response(exc, None, code='VALIDATION_ERROR', message='입력값이 올바르지 않습니다.'),
            status=status.HTTP_400_BAD_REQUEST
        )

    # 예상치 못한 예외 (500 에러)
    logger.exception(f"Unhandled exception in {view_name}: {exc}")
    return Response(
        {
            'error': {
                'code': 'INTERNAL_ERROR',
                'message': '서버 내부 오류가 발생했습니다. 잠시 후 다시 시도해주세요.',
            }
        },
        status=status.HTTP_500_INTERNAL_SERVER_ERROR
    )


def format_error_response(exc, response, code=None, message=None):
    """에러 응답 형식 표준화"""

    # Rate Limit 초과
    if isinstance(exc, Throttled):
        return {
            'error': {
                'code': 'RATE_LIMIT_EXCEEDED',
                'message': f'요청이 너무 많습니다. {exc.wait}초 후에 다시 시도해주세요.',
                'retry_after': exc.wait,
            }
        }

    # 기본 에러 코드 추출
    if code is None:
        code = getattr(exc, 'default_code', 'ERROR')
        if hasattr(exc, 'status_code'):
            code = {
                400: 'BAD_REQUEST',
                401: 'UNAUTHORIZED',
                403: 'FORBIDDEN',
                404: 'NOT_FOUND',
                405: 'METHOD_NOT_ALLOWED',
                429: 'RATE_LIMIT_EXCEEDED',
                500: 'INTERNAL_ERROR',
            }.get(exc.status_code, code)

    # 메시지 추출
    if message is None:
        if hasattr(exc, 'detail'):
            message = str(exc.detail)
        else:
            message = str(exc)

    return {
        'error': {
            'code': code.upper() if isinstance(code, str) else 'ERROR',
            'message': message,
        }
    }
</file>

<file path="backend/dagu/migrations/__init__.py">

</file>

<file path="backend/dagu/migrations/0001_initial.py">
# Generated by Django 5.2.8 on 2026-01-15 03:58

import dagu.models
import django.db.models.deletion
import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Instrument',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=200, verbose_name='모델명')),
                ('brand', models.CharField(max_length=100, verbose_name='브랜드')),
                ('category', models.CharField(choices=[('guitar', '기타'), ('bass', '베이스'), ('keyboard', '키보드/신디'), ('drum', '드럼/퍼커션'), ('effect', '이펙터'), ('amp', '앰프'), ('acoustic', '어쿠스틱'), ('other', '기타 악기')], default='guitar', max_length=50, verbose_name='카테고리')),
                ('image_url', models.URLField(blank=True, verbose_name='대표 이미지 URL')),
                ('reference_price', models.PositiveIntegerField(default=0, help_text='신품 정가 (원)', verbose_name='신품 기준가')),
                ('description', models.TextField(blank=True, verbose_name='설명')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'verbose_name': '악기',
                'verbose_name_plural': '악기 목록',
                'ordering': ['brand', 'name'],
                'indexes': [models.Index(fields=['brand'], name='dagu_instru_brand_9bf97b_idx'), models.Index(fields=['category'], name='dagu_instru_categor_0dc989_idx'), models.Index(fields=['name'], name='dagu_instru_name_1f8469_idx')],
            },
        ),
        migrations.CreateModel(
            name='UserItem',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('price', models.PositiveIntegerField(verbose_name='판매가')),
                ('link', models.URLField(verbose_name='판매 링크')),
                ('source', models.CharField(choices=[('bunjang', '번개장터'), ('joonggonara', '중고나라'), ('danggn', '당근마켓'), ('other', '기타')], default='other', max_length=50, verbose_name='출처')),
                ('title', models.CharField(blank=True, max_length=300, verbose_name='매물 제목')),
                ('is_active', models.BooleanField(default=True, verbose_name='활성 상태')),
                ('expired_at', models.DateTimeField(db_index=True, default=dagu.models.default_expiry, verbose_name='만료 시간')),
                ('click_count', models.PositiveIntegerField(default=0, verbose_name='클릭 수')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('instrument', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='user_items', to='dagu.instrument', verbose_name='악기')),
            ],
            options={
                'verbose_name': '중고 매물',
                'verbose_name_plural': '중고 매물 목록',
                'ordering': ['price', '-created_at'],
                'indexes': [models.Index(fields=['is_active', 'expired_at'], name='dagu_userit_is_acti_d17b95_idx'), models.Index(fields=['price'], name='dagu_userit_price_56eff5_idx')],
            },
        ),
    ]
</file>

<file path="backend/dagu/migrations/0002_alter_instrument_image_url_alter_instrument_name_and_more.py">
# Generated by Django 5.2.8 on 2026-01-15 06:01

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('dagu', '0001_initial'),
    ]

    operations = [
        migrations.AlterField(
            model_name='instrument',
            name='image_url',
            field=models.URLField(blank=True, max_length=2000, verbose_name='대표 이미지 URL'),
        ),
        migrations.AlterField(
            model_name='instrument',
            name='name',
            field=models.CharField(max_length=500, verbose_name='모델명'),
        ),
        migrations.AlterField(
            model_name='useritem',
            name='link',
            field=models.URLField(max_length=2000, verbose_name='판매 링크'),
        ),
    ]
</file>

<file path="backend/dagu/migrations/0003_alter_useritem_source.py">
# Generated by Django 5.2.8 on 2026-01-15 06:05

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('dagu', '0002_alter_instrument_image_url_alter_instrument_name_and_more'),
    ]

    operations = [
        migrations.AlterField(
            model_name='useritem',
            name='source',
            field=models.CharField(choices=[('bunjang', '번개장터'), ('joonggonara', '중고나라'), ('danggn', '당근마켓'), ('mule', '뮬'), ('other', '기타')], default='other', max_length=50, verbose_name='출처'),
        ),
    ]
</file>

<file path="backend/dagu/models.py">
"""
Database models for MALCHA-DAGU.

- Instrument: 악기 마스터 데이터 (관리자만 수정 가능)
- UserItem: 유저가 등록한 중고 매물 (만료 시간 자동 관리)
"""

import uuid
from datetime import timedelta

from django.db import models
from django.utils import timezone


def default_expiry():
    """기본 만료 시간: 72시간 후"""
    return timezone.now() + timedelta(hours=72)


class Instrument(models.Model):
    """
    악기 마스터 테이블.
    이 데이터는 관리자만 생성/수정 가능.
    """
    
    CATEGORY_CHOICES = [
        ('guitar', '기타'),
        ('bass', '베이스'),
        ('keyboard', '키보드/신디'),
        ('drum', '드럼/퍼커션'),
        ('effect', '이펙터'),
        ('amp', '앰프'),
        ('acoustic', '어쿠스틱'),
        ('other', '기타 악기'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=500, verbose_name='모델명')
    brand = models.CharField(max_length=100, verbose_name='브랜드')
    category = models.CharField(
        max_length=50, 
        choices=CATEGORY_CHOICES, 
        default='guitar',
        verbose_name='카테고리'
    )
    image_url = models.URLField(max_length=2000, blank=True, verbose_name='대표 이미지 URL')
    reference_price = models.PositiveIntegerField(
        default=0, 
        verbose_name='신품 기준가',
        help_text='신품 정가 (원)'
    )
    description = models.TextField(blank=True, verbose_name='설명')
    
    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        verbose_name = '악기'
        verbose_name_plural = '악기 목록'
        ordering = ['brand', 'name']
        indexes = [
            models.Index(fields=['brand']),
            models.Index(fields=['category']),
            models.Index(fields=['name']),
        ]
    
    def __str__(self):
        return f"{self.brand} {self.name}"


class UserItem(models.Model):
    """
    유저가 등록한 중고 매물.
    만료 시간이 지나면 자동으로 비활성화됨 (Celery Beat).
    """
    
    SOURCE_CHOICES = [
        ('bunjang', '번개장터'),
        ('joonggonara', '중고나라'),
        ('danggn', '당근마켓'),
        ('mule', '뮬'),
        ('other', '기타'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    instrument = models.ForeignKey(
        Instrument, 
        on_delete=models.CASCADE, 
        related_name='user_items',
        verbose_name='악기'
    )
    price = models.PositiveIntegerField(verbose_name='판매가')
    link = models.URLField(max_length=2000, verbose_name='판매 링크')
    source = models.CharField(
        max_length=50, 
        choices=SOURCE_CHOICES, 
        default='other',
        verbose_name='출처'
    )
    title = models.CharField(max_length=300, blank=True, verbose_name='매물 제목')
    
    # Status & Lifecycle
    is_active = models.BooleanField(default=True, verbose_name='활성 상태')
    expired_at = models.DateTimeField(
        default=default_expiry, 
        db_index=True,  # 성능 핵심: 인덱싱 필수
        verbose_name='만료 시간'
    )
    click_count = models.PositiveIntegerField(default=0, verbose_name='클릭 수')

    # 소유자 정보 (JWT user_id 저장, FK 없이 정수만)
    owner_id = models.IntegerField(
        null=True, blank=True,
        db_index=True,
        verbose_name='등록자 ID'
    )
    extended_at = models.DateTimeField(
        null=True, blank=True,
        verbose_name='연장 시점'
    )

    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        verbose_name = '중고 매물'
        verbose_name_plural = '중고 매물 목록'
        ordering = ['price', '-created_at']
        indexes = [
            models.Index(fields=['is_active', 'expired_at']),
            models.Index(fields=['price']),
        ]
    
    def __str__(self):
        return f"{self.instrument} - ₩{self.price:,}"
    
    @property
    def is_expired(self):
        """만료 여부 확인"""
        return timezone.now() > self.expired_at
    
    @property
    def discount_rate(self):
        """신품 대비 할인율 계산"""
        if self.instrument.reference_price > 0:
            discount = (1 - self.price / self.instrument.reference_price) * 100
            return round(discount, 1)
        return 0
    
    def extend_expiry(self, hours=12):
        """
        클릭 시 만료 시간 연장.
        동시성 문제를 피하기 위해 save() 대신 update() 권장.
        """
        self.expired_at = timezone.now() + timedelta(hours=hours)
        self.save(update_fields=['expired_at', 'updated_at'])
</file>

<file path="backend/dagu/serializers.py">
"""
Serializers for MALCHA-DAGU API.
"""

from rest_framework import serializers

from .models import Instrument, UserItem


class InstrumentSerializer(serializers.ModelSerializer):
    """악기 마스터 시리얼라이저"""
    
    category_display = serializers.CharField(
        source='get_category_display', 
        read_only=True
    )
    
    class Meta:
        model = Instrument
        fields = [
            'id', 'name', 'brand', 'category', 'category_display',
            'image_url', 'reference_price', 'description',
            'created_at', 'updated_at'
        ]
        read_only_fields = ['id', 'created_at', 'updated_at']


class InstrumentMinimalSerializer(serializers.ModelSerializer):
    """악기 간단 정보 (목록용)"""
    
    class Meta:
        model = Instrument
        fields = ['id', 'name', 'brand', 'image_url', 'reference_price']


class UserItemSerializer(serializers.ModelSerializer):
    """유저 매물 시리얼라이저"""

    instrument_detail = InstrumentMinimalSerializer(
        source='instrument',
        read_only=True
    )
    source_display = serializers.CharField(
        source='get_source_display',
        read_only=True
    )
    discount_rate = serializers.FloatField(read_only=True)
    is_expired = serializers.BooleanField(read_only=True)
    is_owner = serializers.SerializerMethodField()

    class Meta:
        model = UserItem
        fields = [
            'id', 'instrument', 'instrument_detail', 'price', 'link',
            'source', 'source_display', 'title', 'is_active',
            'expired_at', 'extended_at', 'click_count', 'discount_rate',
            'is_expired', 'is_owner', 'owner_id',
            'created_at', 'updated_at'
        ]
        read_only_fields = [
            'id', 'click_count', 'owner_id', 'extended_at', 'created_at', 'updated_at'
        ]

    def get_is_owner(self, obj):
        """현재 요청 유저가 소유자인지 확인"""
        request = self.context.get('request')
        if request and request.user.is_authenticated:
            return obj.owner_id == request.user.id
        return False


class UserItemCreateSerializer(serializers.ModelSerializer):
    """유저 매물 생성용 시리얼라이저"""
    
    class Meta:
        model = UserItem
        fields = ['instrument', 'price', 'link', 'source', 'title']
        extra_kwargs = {
            'instrument': {'required': False, 'allow_null': True}
        }


class NaverItemSerializer(serializers.Serializer):
    """네이버 쇼핑 API 응답 시리얼라이저"""
    
    title = serializers.CharField()
    link = serializers.URLField()
    image = serializers.URLField()
    lprice = serializers.IntegerField()  # 최저가
    hprice = serializers.IntegerField(required=False, default=0)  # 최고가
    mallName = serializers.CharField()
    productId = serializers.CharField()
    productType = serializers.IntegerField()
    
    # 가공된 필드
    source = serializers.SerializerMethodField()
    
    def get_source(self, obj):
        return 'naver'


class SearchResultSerializer(serializers.Serializer):
    """통합 검색 결과 시리얼라이저"""
    
    # 검색 메타 정보
    query = serializers.CharField()
    total_count = serializers.IntegerField()
    
    # 신품 정보
    reference = serializers.DictField(required=False)
    
    # 가격순 정렬된 통합 결과
    items = serializers.ListField()
    
    # 네이버 결과만
    naver_items = serializers.ListField()
    
    # 유저 매물만
    user_items = serializers.ListField()


class AIDescriptionRequestSerializer(serializers.Serializer):
    """AI 설명 요청 시리얼라이저"""
    
    model_name = serializers.CharField(max_length=200)
    brand = serializers.CharField(max_length=100)
    category = serializers.CharField(max_length=50)


class AIDescriptionResponseSerializer(serializers.Serializer):
    """AI 설명 응답 시리얼라이저"""
    
    summary = serializers.CharField()
    check_point = serializers.CharField(allow_blank=True)
</file>

<file path="backend/dagu/services/__init__.py">
"""
Services package for MALCHA-DAGU.

This package contains the core business logic split into focused modules:
- naver: Naver Shopping API integration
- search: Search aggregation service
- ai: AI description generation
- utils: Search utility functions
"""

from .naver import NaverShoppingService
from .search import SearchAggregatorService
# from .ai import AIDescriptionService  # 임시 비활성화
from .utils import (
    normalize_search_term,
    expand_query_with_aliases,
    tokenize_query,
    calculate_instrument_match_score,
    find_best_matching_instruments,
)

__all__ = [
    # Services
    'NaverShoppingService',
    'SearchAggregatorService',
    # 'AIDescriptionService',  # 임시 비활성화
    # Utilities
    'normalize_search_term',
    'expand_query_with_aliases',
    'tokenize_query',
    'calculate_instrument_match_score',
    'find_best_matching_instruments',
]
</file>

<file path="backend/dagu/services/ai.py">
"""
AI Description Service for MALCHA-DAGU.

Generates instrument descriptions using OpenAI API with
prompt engineering to prevent hallucinations.
"""

import logging

import requests
from django.conf import settings

logger = logging.getLogger(__name__)


class AIDescriptionService:
    """
    AI 악기 설명 생성 서비스.
    할루시네이션 방지를 위한 프롬프트 엔지니어링 적용.
    """

    def __init__(self):
        self.api_key = settings.OPENAI_API_KEY
        self.api_url = 'https://api.openai.com/v1/chat/completions'

    def generate_description(
        self,
        model_name: str,
        brand: str,
        category: str
    ) -> dict[str, str]:
        """
        악기 설명 생성 (할루시네이션 방지 적용).

        Returns:
            {'summary': str, 'check_point': str}
        """
        if not self.api_key:
            logger.warning("OpenAI API key not configured")
            return {
                'summary': f'{brand} {model_name} - 믿을 수 있는 선택',
                'check_point': '',
            }

        # 할루시네이션 방지 프롬프트
        system_prompt = """너는 악기 전문가이자 팩트 체크에 엄격한 에디터다.
사용자가 요청한 악기에 대한 '한 줄 평'과 '구매 가이드'를 작성하라.

# Rules (Strict)
1. **No Hallucination:** Input Data와 너의 지식 베이스가 100% 일치하는 팩트만 서술하라.
   출시 연도나 세부 스펙이 확실하지 않으면 절대 언급하지 말고 톤/음색 특징 위주로 서술하라.
2. **Tone:** "이 악기는~" 처럼 지루하게 시작하지 마라.
   "따뜻한 배음이 매력적입니다", "입문용으로 최고의 선택입니다" 같이 핵심부터 찌르는 간결한 문체를 써라.
3. **Structure:**
   - [summary]: 20자 이내 임팩트 있는 문구.
   - [check_point]: 중고 거래 시 반드시 확인해야 할 고질병(노브 잡음, 넥 휨 등) 1가지. 모르면 빈 문자열.

JSON 형식으로 { "summary": "...", "check_point": "..." } 만 출력하라."""

        user_prompt = f"""# Input Data
- 모델명: {model_name}
- 브랜드: {brand}
- 카테고리: {category}"""

        try:
            import json
            response = requests.post(
                self.api_url,
                headers={
                    'Authorization': f'Bearer {self.api_key}',
                    'Content-Type': 'application/json',
                },
                json={
                    'model': 'gpt-4o-mini',
                    'messages': [
                        {'role': 'system', 'content': system_prompt},
                        {'role': 'user', 'content': user_prompt},
                    ],
                    'temperature': 0.2,  # 창의성 낮춤 (팩트 위주)
                    'max_tokens': 200,
                },
                timeout=10,
            )
            response.raise_for_status()

            data = response.json()
            content = data['choices'][0]['message']['content']

            # JSON 파싱
            result = json.loads(content)
            return {
                'summary': result.get('summary', ''),
                'check_point': result.get('check_point', ''),
            }

        except Exception as e:
            logger.exception(f"AI description generation error: {e}")
            return {
                'summary': f'{brand} {model_name}',
                'check_point': '',
            }
</file>

<file path="backend/dagu/services/naver.py">
"""
Naver Shopping API Service for MALCHA-DAGU.

Provides search functionality with caching and quality filtering.
"""

from __future__ import annotations

import concurrent.futures
import hashlib
import logging
from typing import Any

import requests
from django.conf import settings
from django.core.cache import cache

from ..config import CrawlerConfig
from ..filters import filter_naver_item, filter_naver_item_with_reason
from .utils import normalize_brand

logger = logging.getLogger(__name__)

# =============================================================================
# Constants
# =============================================================================

NAVER_API_URL = 'https://openapi.naver.com/v1/search/shop.json'
CACHE_TTL = 60 * 60  # 1시간


# =============================================================================
# Naver Shopping API Service
# =============================================================================

class NaverShoppingService:
    """
    네이버 쇼핑 API 연동 서비스.

    Features:
        - Redis 캐싱 (1시간 TTL)
        - 병렬 페이지 요청 (ThreadPoolExecutor)
        - 6단계 품질 필터링
        - 한글 브랜드명 정규화

    Usage:
        >>> service = NaverShoppingService()
        >>> results = service.search("BOSS DS-1", display=20)
    """

    def __init__(self) -> None:
        self.client_id = settings.NAVER_CLIENT_ID
        self.client_secret = settings.NAVER_CLIENT_SECRET
        self.headers = {
            'X-Naver-Client-Id': self.client_id,
            'X-Naver-Client-Secret': self.client_secret,
        }
        self._timeout = CrawlerConfig.TIMEOUT_NAVER

    def _get_cache_key(
        self,
        query: str,
        display: int,
        brand: str | None = None,
        category: str | None = None,
        min_price: int | None = None,
    ) -> str:
        """캐시 키 생성 (검색어 + 필터 조건 해시)"""
        key_base = f"naver_search:{query}:{display}:{brand or ''}:{category or ''}:{min_price or ''}"
        return hashlib.md5(key_base.encode()).hexdigest()

    def _normalize_query(self, query: str) -> str:
        """검색어 정규화 (한글 브랜드 -> 영문)"""
        return normalize_brand(query)

    def _fetch_page(self, query: str, start: int, sort: str) -> list[dict]:
        """단일 페이지 API 요청"""
        try:
            params = {
                'query': query,
                'display': 100,
                'start': start,
                'sort': sort,
                'exclude': 'rental',
            }
            response = requests.get(
                NAVER_API_URL,
                headers=self.headers,
                params=params,
                timeout=self._timeout,
            )
            response.raise_for_status()
            return response.json().get('items', [])

        except requests.exceptions.RequestException as e:
            logger.error(f"Naver API Error (start={start}): {e}")
            return []

    def _fetch_all_pages(self, query: str, sort: str, target_count: int = 200) -> list[dict]:
        """병렬 페이지 요청으로 대량 아이템 수집"""
        page_size = 100
        starts = list(range(1, target_count, page_size))

        all_items = []

        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            logger.info(f"병렬 수집 시작: {target_count}개 목표")

            futures = {
                executor.submit(self._fetch_page, query, start, sort): start
                for start in starts
            }

            for future in concurrent.futures.as_completed(futures):
                items = future.result()
                all_items.extend(items)

        logger.info(f"병렬 수집 완료: 총 {len(all_items)}개 아이템")
        return all_items

    def search(
        self,
        query: str,
        display: int = 20,
        sort: str = 'sim',
        brand: str | None = None,
        category: str | None = None,
        min_price: int | None = None,
    ) -> list[dict[str, Any]]:
        """
        네이버 쇼핑 API 검색 + 필터링.

        Args:
            query: 검색어
            display: 결과 개수 (최대 100)
            sort: 정렬 (sim: 정확도, date: 날짜, asc: 가격낮은순, dsc: 가격높은순)
            brand: 브랜드 필터 (선택)
            category: 카테고리 필터 (선택)
            min_price: 최소 가격 필터 (선택)

        Returns:
            필터링된 검색 결과 리스트
        """
        # API 키 확인 - 누락 시 명확한 예외 발생
        if not self.client_id or not self.client_secret:
            logger.critical("Naver API credentials not configured - Search unavailable")
            from django.core.exceptions import ImproperlyConfigured
            raise ImproperlyConfigured(
                "NAVER_CLIENT_ID and NAVER_CLIENT_SECRET must be set for search functionality"
            )

        # 검색어 정규화
        normalized_query = self._normalize_query(query)

        # 캐시 확인 (필터 조건 포함)
        cache_key = self._get_cache_key(
            normalized_query, display * 3, brand, category, min_price
        )
        cached_result = cache.get(cache_key)

        if cached_result is not None:
            logger.debug(f"Cache HIT: {query}")
            raw_items = cached_result
        else:
            logger.info(f"Cache MISS - API 호출: {query}")

            try:
                raw_items = self._fetch_all_pages(normalized_query, sort)
                cache.set(cache_key, raw_items, CACHE_TTL)
                logger.debug(f"[Cache] 저장 완료: {len(raw_items)}개")

            except Exception as e:
                logger.exception(f"Naver API error: {e}")
                return []

        # 필터링 적용
        filtered_items = self._apply_filters(
            raw_items, query, brand, category, min_price, display
        )

        # 스코어순 -> 가격순 정렬
        filtered_items.sort(key=lambda x: (-x.get('score', 0), x.get('lprice', 0)))

        self._log_results(raw_items, filtered_items, display)

        return filtered_items[:display]

    def _apply_filters(
        self,
        items: list[dict],
        query: str,
        brand: str | None,
        category: str | None,
        min_price: int | None,
        display: int,
    ) -> list[dict]:
        """아이템 필터링 적용 (상세 로그 포함)"""
        filtered = []
        filter_stats = {
            'price': 0,
            'blacklist': 0,
            'brand': 0,
            'category': 0,
            'category_fields': 0,
            'product_type': 0,
            'passed': 0,
        }

        for item in items:
            result, reason = filter_naver_item_with_reason(
                item=item,
                query=query,
                brand=brand,
                category=category,
                min_price=min_price,
            )
            if result:
                filter_stats['passed'] += 1
                filtered.append(result)
            else:
                filter_stats[reason] = filter_stats.get(reason, 0) + 1

        # 필터링 통계 로그
        logger.info(
            f"[필터 통계] 통과: {filter_stats['passed']} | "
            f"가격: {filter_stats['price']} | "
            f"블랙리스트: {filter_stats['blacklist']} | "
            f"브랜드: {filter_stats['brand']} | "
            f"카테고리: {filter_stats['category']} | "
            f"액세서리: {filter_stats['category_fields']} | "
            f"상품타입: {filter_stats['product_type']}"
        )

        # NOTE: truncation은 정렬 후 search()에서 수행
        return filtered

    def _log_results(
        self,
        raw_items: list[dict],
        filtered_items: list[dict],
        display: int,
    ) -> None:
        """결과 로깅"""
        logger.info(
            f"[Naver] 필터링: 원본({len(raw_items)}) -> "
            f"통과({len(filtered_items)}) -> 반환({min(len(filtered_items), display)})"
        )

        if filtered_items:
            logger.info("상위 결과:")
            for i, item in enumerate(filtered_items[:3], 1):
                logger.info(
                    f"  {i}. [{item['lprice']:,}원] "
                    f"{item['title'][:40]}... ({item.get('mallName', 'N/A')})"
                )
</file>

<file path="backend/dagu/services/search.py">
"""
Search Aggregator Service for MALCHA-DAGU.

Combines Naver Shopping API results with user-posted listings.
"""

from __future__ import annotations

import logging
from typing import Any

from django.db import models
from django.utils import timezone

from ..config import CategoryConfig
from ..filters import calculate_match_score, filter_user_item
from ..models import Instrument, UserItem
from .naver import NaverShoppingService
from .utils import (
    normalize_search_term,
    tokenize_query,
    expand_query_with_aliases,
    find_best_matching_instruments,
    extract_brand,
    normalize_brand,
)

logger = logging.getLogger(__name__)


class SearchAggregatorService:
    """
    네이버 쇼핑 + DB 유저 매물 통합 검색 서비스.

    Flow:
        1. DB에서 검색어와 매칭되는 Instrument 찾기 (스코어 기반)
        2. 매칭된 악기 정보로 네이버 API 검색 최적화
        3. 유저 등록 매물 검색 (매칭된 악기 우선)
        4. 가격순 병합 정렬

    Usage:
        >>> service = SearchAggregatorService()
        >>> result = service.search("BOSS DS-1", display=20)
    """

    def __init__(self) -> None:
        self.naver_service = NaverShoppingService()

    def search(self, query: str, display: int = 20) -> dict[str, Any]:
        """
        통합 검색 수행.

        Args:
            query: 검색어
            display: 결과 개수

        Returns:
            {
                'query': str,
                'total_count': int,
                'reference': { ... },  # 신품 기준가 정보
                'items': [ ... ],      # 가격순 통합 결과
                'naver_items': [ ... ],
                'user_items': [ ... ],
            }
        """
        # 브랜드/카테고리 추출 (utils 통합 함수 사용)
        brand = extract_brand(query)
        category = self._detect_category(query)

        logger.debug(f"query='{query}', brand={brand}, category={category}")

        # Step 1: DB에서 매칭 악기 찾기
        matching_instruments, best_match = self._find_matching_instruments(query)

        # Step 2: 네이버 검색 (최적화된 쿼리)
        search_query, brand, category = self._build_search_query(
            query, best_match, brand, category
        )
        naver_items = self.naver_service.search(
            query=search_query,
            display=display,
            brand=brand,
            category=category,
        )

        # Step 3: 유저 매물 검색 (동일 필터 적용)
        user_items, reference_info = self._search_user_items(
            query, matching_instruments, best_match, display, category
        )

        # Step 4: 가격순 + 연장 우선순위 병합
        all_items = naver_items + user_items
        # 정렬: 1) 가격 오름차순, 2) 연장된 매물 우선 (extended_at 있으면 0, 없으면 1)
        all_items.sort(key=lambda x: (
            x.get('lprice', 0),
            0 if x.get('extended_at') else 1
        ))

        logger.info(
            f"검색 완료: 네이버({len(naver_items)}) + "
            f"유저({len(user_items)}) = 총({len(all_items)})"
        )

        return {
            'query': query,
            'total_count': len(all_items),
            'reference': reference_info,
            'items': all_items,
            'naver_items': naver_items,
            'user_items': user_items,
        }

    def _detect_category(self, query: str) -> str:
        """검색어에서 카테고리 추론 (DB 값과 일치)"""
        query_lower = query.lower()

        bass_keywords = getattr(CategoryConfig, 'BASS_KEYWORDS', [])
        pedal_keywords = getattr(CategoryConfig, 'PEDAL_KEYWORDS', [])
        amp_keywords = getattr(CategoryConfig, 'AMP_KEYWORDS', [])
        acoustic_keywords = getattr(CategoryConfig, 'ACOUSTIC_KEYWORDS', [])

        if any(kw in query_lower for kw in bass_keywords):
            return 'bass'
        if any(kw in query_lower for kw in pedal_keywords):
            return 'effect'  # DB: 'effect' = 이펙터
        if any(kw in query_lower for kw in amp_keywords):
            return 'amp'
        if any(kw in query_lower for kw in acoustic_keywords):
            return 'acoustic'

        return 'guitar'

    def _find_matching_instruments(
        self,
        query: str,
    ) -> tuple[list[Instrument], tuple[Instrument, float] | None]:
        """
        DB에서 매칭 악기 찾기 (스마트 매칭).

        Returns:
            (matching_instruments, best_match)
        """
        query_tokens = tokenize_query(query)
        expanded_queries = expand_query_with_aliases(query)

        # 후보 필터 구성
        candidate_filter = models.Q()

        for token in query_tokens:
            candidate_filter |= models.Q(name__icontains=token)
            candidate_filter |= models.Q(brand__icontains=token)

        for expanded in expanded_queries:
            candidate_filter |= models.Q(name__icontains=expanded)
            for token in expanded.split():
                if len(token) > 1:
                    candidate_filter |= models.Q(name__icontains=token)

        query_lower = query.lower().strip()
        candidate_filter |= models.Q(name__icontains=query_lower)
        candidate_filter |= models.Q(brand__icontains=query_lower)

        logger.debug(f"별칭 확장: {query} -> {expanded_queries}")

        # 후보 조회 (Unknown 브랜드 제외)
        candidates = Instrument.objects.filter(
            candidate_filter
        ).exclude(
            brand__iexact='unknown'
        )[:50]

        logger.debug(f"후보 악기 {candidates.count()}개 조회됨")

        # 스코어링 기반 매칭
        scored_matches = find_best_matching_instruments(
            query=query,
            instruments_qs=candidates,
            min_score=0.3,
        )

        matching_instruments = [inst for inst, _ in scored_matches[:10]]
        best_match = scored_matches[0] if scored_matches else None

        if best_match:
            logger.info(
                f"[DB 매칭] '{query}' -> "
                f"'{best_match[0].brand} {best_match[0].name}' "
                f"(score={best_match[1]:.2f})"
            )

        return matching_instruments, best_match

    def _build_search_query(
        self,
        original_query: str,
        best_match: tuple[Instrument, float] | None,
        brand: str | None,
        category: str,
    ) -> tuple[str, str | None, str]:
        """
        네이버 검색용 최적화된 쿼리 생성.

        Returns:
            (search_query, brand, category)
        """
        search_query = original_query
        detected_category = category  # 검색어 기반 카테고리 보존

        if best_match and best_match[1] >= 0.5:
            # 50% 이상 매칭: 악기 정보로 쿼리 치환
            instrument = best_match[0]
            search_query = f"{instrument.brand} {instrument.name}"
            brand = instrument.brand.lower() if instrument.brand else brand
            # 검색어 기반 카테고리 우선 (페달 키워드 감지 시 DB 카테고리 무시)
            if detected_category != 'guitar':
                category = detected_category
            elif instrument.category:
                category = instrument.category
            logger.info(f"[쿼리 변환] '{original_query}' -> '{search_query}' (카테고리: {category})")
        else:
            # 한글 브랜드 -> 영문 치환 (utils 통합 함수 사용)
            search_query = normalize_brand(original_query)

        logger.info(f"검색 시작: '{search_query}' (브랜드: {brand}, 카테고리: {category})")

        return search_query, brand, category

    def _search_user_items(
        self,
        query: str,
        matching_instruments: list[Instrument],
        best_match: tuple[Instrument, float] | None,
        display: int,
        category: str = None,
    ) -> tuple[list[dict], dict | None]:
        """
        유저 매물 검색.

        Returns:
            (user_items, reference_info)
        """
        now = timezone.now()

        if matching_instruments:
            # 매칭된 악기들의 UserItem 검색
            user_items_qs = UserItem.objects.filter(
                is_active=True,
                expired_at__gt=now,
                instrument__in=matching_instruments,
            ).select_related('instrument')[:display * 2]  # 필터링 여유분
        else:
            # 매칭 악기 없으면 제목/브랜드 검색
            user_items_qs = UserItem.objects.filter(
                is_active=True,
                expired_at__gt=now,
            ).filter(
                models.Q(instrument__name__icontains=query) |
                models.Q(instrument__brand__icontains=query) |
                models.Q(title__icontains=query)
            ).select_related('instrument')[:display * 2]

        # 딕셔너리 변환 + 필터링 (네이버와 동일 기준)
        user_items = []
        reference_info = None

        for item in user_items_qs:
            title = item.title or str(item.instrument)

            # 통합 필터 적용 (블랙리스트 + 가격 + 카테고리)
            if not filter_user_item(title, item.price, category):
                continue

            if len(user_items) >= display:
                break

            user_items.append({
                'id': str(item.id),
                'title': title,
                'link': item.link,
                'image': item.instrument.image_url,
                'lprice': item.price,
                'source': item.source,
                'source_display': item.get_source_display(),
                'discount_rate': item.discount_rate,
                'instrument_id': str(item.instrument.id),
                'instrument_name': item.instrument.name,
                'instrument_brand': item.instrument.brand,
                'score': calculate_match_score(query, title, item.instrument.image_url),
                'owner_id': item.owner_id,
                'extended_at': item.extended_at.isoformat() if item.extended_at else None,
            })

            # 신품 기준가 정보 (첫 번째 매물 기준)
            if reference_info is None and item.instrument.reference_price > 0:
                reference_info = {
                    'name': str(item.instrument),
                    'price': item.instrument.reference_price,
                    'image_url': item.instrument.image_url,
                }

        # 기준가 보완 (best_match 또는 DB 검색)
        reference_info = self._get_reference_info(
            reference_info, best_match, query
        )

        return user_items, reference_info

    def _get_reference_info(
        self,
        existing_ref: dict | None,
        best_match: tuple[Instrument, float] | None,
        query: str,
    ) -> dict | None:
        """신품 기준가 정보 조회"""
        if existing_ref:
            return existing_ref

        # best_match 우선
        if best_match:
            instrument = best_match[0]
            if instrument.reference_price > 0:
                return {
                    'name': str(instrument),
                    'price': instrument.reference_price,
                    'image_url': instrument.image_url,
                }

        # DB 검색 fallback
        instrument = Instrument.objects.filter(
            models.Q(name__icontains=query) |
            models.Q(brand__icontains=query)
        ).first()

        if instrument and instrument.reference_price > 0:
            return {
                'name': str(instrument),
                'price': instrument.reference_price,
                'image_url': instrument.image_url,
            }

        return None
</file>

<file path="backend/dagu/services/utils.py">
"""
Search utility functions for MALCHA-DAGU.

Provides search term normalization, alias expansion, and instrument matching.
"""

from __future__ import annotations

import logging
import re
from difflib import SequenceMatcher
from functools import lru_cache
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from django.db.models import QuerySet
    from ..models import Instrument

logger = logging.getLogger(__name__)


# =============================================================================
# Cached Config Accessors (성능 최적화)
# =============================================================================

@lru_cache(maxsize=1)
def _get_model_aliases() -> dict[str, str]:
    """MODEL_ALIASES 캐시 로드"""
    from ..config import CategoryConfig
    return getattr(CategoryConfig, 'MODEL_ALIASES', {})


@lru_cache(maxsize=1)
def _get_brand_mapping() -> dict[str, str]:
    """BRAND_NAME_MAPPING 캐시 로드"""
    from ..config import CategoryConfig
    return getattr(CategoryConfig, 'BRAND_NAME_MAPPING', {})


@lru_cache(maxsize=1)
def _get_guitar_brands() -> list[str]:
    """GUITAR_BRANDS 캐시 로드"""
    from ..config import CategoryConfig
    return getattr(CategoryConfig, 'GUITAR_BRANDS', [])


def clear_config_cache() -> None:
    """설정 캐시 초기화 (설정 변경 시 호출)"""
    _get_model_aliases.cache_clear()
    _get_brand_mapping.cache_clear()
    _get_guitar_brands.cache_clear()
    _get_category_keywords.cache_clear()


# =============================================================================
# Brand Normalization (통합 브랜드 처리)
# =============================================================================

# 알려진 브랜드 목록 (카테고리 추론용)
KNOWN_BRANDS = [
    'boss', 'ibanez', 'jackson', 'charvel', 'schecter', 'suhr',
    'mesa', 'vox', 'marshall', 'orange', 'ampeg', 'tc electronic',
]


def normalize_brand(query: str) -> str:
    """
    검색어에서 한글 브랜드를 영문으로 변환.

    Examples:
        >>> normalize_brand("펜더 스트랫")
        'fender 스트랫'
        >>> normalize_brand("boss ds-1")
        'boss ds-1'

    Args:
        query: 검색어

    Returns:
        영문 브랜드로 치환된 검색어
    """
    brand_mapping = _get_brand_mapping()
    result = query

    for kr_name, en_brand in brand_mapping.items():
        if kr_name in query:
            result = query.replace(kr_name, en_brand)
            logger.debug(f"[Brand] 정규화: '{query}' -> '{result}'")
            break

    return result


def extract_brand(query: str) -> str | None:
    """
    검색어에서 브랜드 추출.

    Examples:
        >>> extract_brand("펜더 스트랫")
        'fender'
        >>> extract_brand("BOSS DS-1")
        'boss'

    Args:
        query: 검색어

    Returns:
        추출된 브랜드 (소문자) 또는 None
    """
    query_lower = query.lower()

    # 한글 브랜드 매핑 체크
    brand_mapping = _get_brand_mapping()
    for kr_name, en_brand in brand_mapping.items():
        if kr_name in query_lower:
            return en_brand

    # 알려진 브랜드 목록에서 찾기
    guitar_brands = _get_guitar_brands()
    all_brands = guitar_brands + KNOWN_BRANDS

    for brand in all_brands:
        if brand in query_lower:
            return brand

    # 첫 단어를 브랜드로 가정 (2글자 이상)
    words = query.split()
    if words and len(words[0]) > 2:
        return words[0].lower()

    return None


# =============================================================================
# Category Detection
# =============================================================================

@lru_cache(maxsize=1)
def _get_category_keywords() -> dict[str, list[str]]:
    """카테고리별 키워드 캐시 로드"""
    from ..config import CategoryConfig
    return {
        'bass': getattr(CategoryConfig, 'BASS_KEYWORDS', []),
        'effect': getattr(CategoryConfig, 'PEDAL_KEYWORDS', []),
        'amp': getattr(CategoryConfig, 'AMP_KEYWORDS', []),
        'acoustic': getattr(CategoryConfig, 'ACOUSTIC_KEYWORDS', []),
    }


def detect_category(text: str) -> str:
    """
    텍스트에서 악기 카테고리 추론.

    Examples:
        >>> detect_category("BOSS DS-1 디스토션 페달")
        'effect'
        >>> detect_category("Fender Jazz Bass")
        'bass'
        >>> detect_category("Gibson Les Paul")
        'guitar'

    Args:
        text: 제목 또는 검색어

    Returns:
        카테고리 ('guitar', 'bass', 'effect', 'amp', 'acoustic')
    """
    text_lower = text.lower()
    keywords = _get_category_keywords()

    for category, kw_list in keywords.items():
        if any(kw in text_lower for kw in kw_list):
            return category

    return 'guitar'  # 기본값


# =============================================================================
# Search Term Normalization
# =============================================================================

def normalize_search_term(term: str) -> str:
    """
    검색어 정규화: 대소문자, 하이픈, 공백 통일.

    Examples:
        >>> normalize_search_term("DS-1")
        'ds1'
        >>> normalize_search_term("ds 1")
        'ds1'
        >>> normalize_search_term("Les Paul")
        'lespaul'

    Args:
        term: 원본 검색어

    Returns:
        정규화된 검색어 (소문자, 특수문자 제거)
    """
    if not term:
        return ""

    result = term.lower().strip()
    # 하이픈, 언더스코어, 공백 제거
    result = re.sub(r'[-_\s]+', '', result)
    return result


def tokenize_query(query: str) -> list[str]:
    """
    검색어를 토큰으로 분리.

    Examples:
        >>> tokenize_query("boss ds-1")
        ['boss', 'ds-1', 'ds1']
        >>> tokenize_query("Fender Strat")
        ['fender', 'strat']

    Args:
        query: 검색어

    Returns:
        토큰 리스트 (원본 + 정규화된 버전)
    """
    tokens = []
    words = query.lower().strip().split()

    for word in words:
        tokens.append(word)
        # 하이픈 제거 버전도 추가 (ds-1 -> ds1)
        normalized = re.sub(r'[-_]+', '', word)
        if normalized != word:
            tokens.append(normalized)

    return list(set(tokens))


def expand_query_with_aliases(query: str) -> list[str]:
    """
    검색어를 별칭 매핑으로 확장.

    Examples:
        >>> expand_query_with_aliases("ds1")
        ['ds1', 'DS-1']
        >>> expand_query_with_aliases("strat")
        ['strat', 'Stratocaster']

    Args:
        query: 검색어

    Returns:
        확장된 검색어 리스트 (원본 + 별칭 매핑된 정식명)
    """
    aliases = _get_model_aliases()
    expanded = [query]

    query_lower = query.lower().strip()
    query_normalized = normalize_search_term(query)

    # 정규화된 검색어로 별칭 찾기
    if query_normalized in aliases:
        expanded.append(aliases[query_normalized])

    # 원본 검색어(소문자)로도 별칭 찾기
    if query_lower in aliases:
        expanded.append(aliases[query_lower])

    # 각 토큰별로 별칭 확장
    for token in query_lower.split():
        token_norm = normalize_search_term(token)
        if token_norm in aliases:
            expanded.append(aliases[token_norm])
        if token in aliases:
            expanded.append(aliases[token])

    return list(set(expanded))


# =============================================================================
# Instrument Matching
# =============================================================================

def calculate_instrument_match_score(query: str, instrument: Instrument) -> float:
    """
    검색어와 악기의 매칭 스코어 계산.

    Scoring Tiers:
        1.0  - 별칭/정규화 정확 일치
        0.95 - 전체 이름 일치 또는 별칭 포함
        0.9  - 모델명이 검색어에 포함
        0.7  - 검색어가 모델명에 포함 (길이 비율 적용)
        0.6  - 토큰 기반 매칭
        0.5  - 유사도 기반 매칭

    Args:
        query: 검색어
        instrument: Instrument 모델 인스턴스

    Returns:
        0.0 ~ 1.0 사이의 매칭 스코어
    """
    query_normalized = normalize_search_term(query)
    query_tokens = tokenize_query(query)
    expanded_queries = expand_query_with_aliases(query)

    name = instrument.name or ""
    brand = instrument.brand or ""
    name_normalized = normalize_search_term(name)
    brand_normalized = normalize_search_term(brand)
    full_name = f"{brand} {name}".strip()
    full_normalized = normalize_search_term(full_name)

    # Tier 0: 별칭 확장된 쿼리로 정확 매칭
    for expanded in expanded_queries:
        expanded_norm = normalize_search_term(expanded)
        if expanded_norm == name_normalized:
            logger.debug(f"[Score 1.0] 별칭 정확 일치: '{expanded}' == '{name}'")
            return 1.0
        if expanded.lower() in name.lower():
            logger.debug(f"[Score 0.95] 별칭 포함: '{expanded}' in '{name}'")
            return 0.95

    # Tier 1: 정규화된 모델명 정확 일치
    if query_normalized == name_normalized:
        logger.debug(f"[Score 1.0] 정확 일치: '{query}' == '{name}'")
        return 1.0

    # Tier 2: 전체 이름(브랜드+모델) 정확 일치
    if query_normalized == full_normalized:
        logger.debug(f"[Score 0.95] 전체 일치: '{query}' == '{full_name}'")
        return 0.95

    # Tier 3: 모델명이 검색어에 포함
    if name_normalized and name_normalized in query_normalized:
        logger.debug(f"[Score 0.9] 모델명 포함: '{name}' in '{query}'")
        return 0.9

    # Tier 4: 검색어가 모델명에 포함 (길이 비율 적용)
    if query_normalized and query_normalized in name_normalized:
        length_ratio = len(query_normalized) / len(name_normalized) if name_normalized else 0
        score = max(0.7 * length_ratio, 0.3)
        logger.debug(f"[Score {score:.2f}] 부분 포함: '{query}' in '{name}'")
        return score

    # Tier 5: 토큰 기반 매칭
    all_tokens = query_tokens.copy()
    for expanded in expanded_queries:
        all_tokens.extend(tokenize_query(expanded))
    all_tokens = list(set(all_tokens))

    matched_tokens = sum(
        1 for token in all_tokens
        if normalize_search_term(token) in name_normalized
        or normalize_search_term(token) in brand_normalized
    )

    if matched_tokens > 0 and all_tokens:
        score = 0.6 * (matched_tokens / len(all_tokens))
        logger.debug(f"[Score {score:.2f}] 토큰 매칭: {matched_tokens}/{len(all_tokens)}")
        return score

    # Tier 6: 유사도 기반 매칭 (fallback)
    similarity = SequenceMatcher(None, query_normalized, name_normalized).ratio()
    if similarity > 0.6:
        score = 0.5 * similarity
        logger.debug(f"[Score {score:.2f}] 유사도: {similarity:.2f}")
        return score

    return 0.0


def find_best_matching_instruments(
    query: str,
    instruments_qs: QuerySet[Instrument],
    min_score: float = 0.3,
) -> list[tuple[Instrument, float]]:
    """
    검색어에 가장 잘 맞는 악기들을 스코어 순으로 반환.

    Args:
        query: 검색어
        instruments_qs: Instrument QuerySet
        min_score: 최소 스코어 (이하는 제외)

    Returns:
        (instrument, score) 튜플 리스트, 스코어 내림차순 정렬
    """
    scored_instruments = [
        (instrument, calculate_instrument_match_score(query, instrument))
        for instrument in instruments_qs
    ]

    # 최소 스코어 이상만 필터링
    scored_instruments = [
        (inst, score) for inst, score in scored_instruments
        if score >= min_score
    ]

    # 스코어 내림차순 정렬
    scored_instruments.sort(key=lambda x: x[1], reverse=True)

    if scored_instruments:
        best = scored_instruments[0]
        logger.info(
            f"[매칭 결과] query='{query}' -> "
            f"Best: {best[0].brand} {best[0].name} (score={best[1]:.2f})"
        )

    return scored_instruments
</file>

<file path="backend/dagu/tasks.py">
"""
Celery tasks for MALCHA-DAGU.
Scheduled tasks for automatic cleanup.
"""

import logging

from celery import shared_task
from django.utils import timezone

from .models import UserItem

logger = logging.getLogger(__name__)


@shared_task(name='dagu.cleanup_expired_items')
def cleanup_expired_items():
    """
    만료된 매물 자동 비활성화.
    Celery Beat로 10분마다 실행.
    
    Soft Delete: is_active = False
    (실제 삭제는 하지 않음 - 데이터 보존)
    """
    now = timezone.now()
    
    # 만료되었지만 아직 활성 상태인 항목 조회
    expired_items = UserItem.objects.filter(
        is_active=True,
        expired_at__lte=now,
    )
    
    count = expired_items.count()
    
    if count > 0:
        # 일괄 업데이트 (효율적)
        expired_items.update(is_active=False)
        logger.info(f"Deactivated {count} expired items")
    else:
        logger.debug("No expired items to cleanup")
    
    return f"Processed {count} items"


@shared_task(name='dagu.purge_old_inactive_items')
def purge_old_inactive_items(days=30):
    """
    오래된 비활성 매물 완전 삭제.
    월 1회 정도 실행 권장.
    
    Args:
        days: 비활성화 후 며칠이 지난 항목을 삭제할지
    """
    from datetime import timedelta
    
    cutoff_date = timezone.now() - timedelta(days=days)
    
    old_items = UserItem.objects.filter(
        is_active=False,
        updated_at__lte=cutoff_date,
    )
    
    count = old_items.count()
    
    if count > 0:
        old_items.delete()
        logger.info(f"Purged {count} old inactive items")
    
    return f"Purged {count} items"
</file>

<file path="backend/dagu/tests.py">
from django.test import TestCase

# Create your tests here.
</file>

<file path="backend/manage.py">
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
</file>

<file path="backend/SEARCH_LOGIC.md">
# DAGU 검색 로직 문서

## 개요
DAGU 검색 시스템은 **Instrument(악기) 중심**으로 동작합니다.  
사용자가 모델명이나 브랜드를 검색하면, DB에서 매칭되는 악기를 먼저 찾고,  
그 악기의 정확한 브랜드+모델명으로 네이버 API를 검색합니다.

---

## 검색 흐름

```
사용자 입력: "ds-1" 또는 "boss ds-1" 또는 "보스 ds-1"
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 1. DB Instrument 검색                                    │
│    - name 또는 brand에 검색어 포함된 악기 찾기            │
│    - 'Unknown' 브랜드는 제외                             │
│    - 예: 'ds-1' → DB에서 'BOSS DS-1' 악기 발견           │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 2. 검색어 결정                                           │
│    - 매칭된 악기 있음 → "{브랜드} {모델명}" 사용          │
│      예: "BOSS DS-1"                                     │
│    - 매칭 없음 → 원본 검색어 사용 (한글→영어 변환)        │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 3. 네이버 API 검색                                       │
│    - 결정된 검색어로 네이버 쇼핑 검색                     │
│    - 필터링 적용:                                        │
│      • 가격 필터 (페달: 5만원+, 기타: 20만원+)            │
│      • 블랙리스트 (부품, 케이스 등 제외)                  │
│      • 브랜드 무결성 체크                                 │
│      • 카테고리 체크                                      │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ 4. 유저 매물 검색 (UserItem)                             │
│    - 매칭된 Instrument의 UserItem들 직접 조회            │
│    - 또는 검색어로 제목/브랜드 검색                       │
│    - 블랙리스트 필터만 적용 (가격 필터 없음)              │
└─────────────────────────────────────────────────────────┘
                    ↓
            네이버 결과 + 유저 매물 종합 → 가격순 정렬 → 반환
```

---

## 핵심 파일

| 파일 | 역할 |
|------|------|
| `services.py` | 검색 로직 메인 (SearchAggregatorService) |
| `config.py` | 설정값 (가격, 블랙리스트, 브랜드 매핑 등) |
| `filters.py` | 필터링 함수들 (가격, 블랙리스트, 브랜드 등) |
| `models.py` | Instrument, UserItem 모델 정의 |

---

## 주요 설정 (config.py)

### 가격 필터
- `MIN_PRICE_KRW = 200000` (악기: 20만원 이상)
- `MIN_PRICE_PEDAL = 50000` (페달: 5만원 이상)

### 카테고리 인식 키워드
- `PEDAL_KEYWORDS`: boss, ds-1, overdrive, distortion 등
- `AMP_KEYWORDS`: amp, cabinet, head, combo 등
- `ACOUSTIC_KEYWORDS`: acoustic, martin, taylor 등

### 한글 브랜드 매핑
```python
BRAND_NAME_MAPPING = {
    '펜더': 'fender',
    '깁슨': 'gibson',
    '보스': 'boss',
    '마샬': 'marshall',
    # ...
}
```

---

## 검색 예시

| 사용자 입력 | DB 매칭 | 네이버 검색어 | 결과 |
|-------------|---------|---------------|------|
| `ds-1` | BOSS DS-1 | "BOSS DS-1" | 페달 결과 ✅ |
| `boss ds-1` | BOSS DS-1 | "BOSS DS-1" | 페달 결과 ✅ |
| `보스 ds-1` | BOSS DS-1 | "boss DS-1" | 페달 결과 ✅ |
| `stratocaster` | (미등록) | "stratocaster" | 기타 결과 ✅ |

---

## 새 악기 추가 방법

1. Django Admin에서 **Instrument** 추가
2. 브랜드, 모델명, 카테고리, 기준가 입력
3. 자동으로 검색에 반영됨 (코드 수정 불필요)

---

## 캐싱

- 네이버 API 결과는 **1시간** 캐싱
- 캐시 키: 정규화된 검색어 + display 수
- 필터링은 매 요청마다 적용
</file>

<file path="frontend/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="frontend/Dockerfile">
# Frontend Dockerfile
FROM node:20-alpine AS builder

WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm ci

# Copy source and build
COPY . .
RUN npm run build

# Production stage with nginx
FROM nginx:alpine

# Copy built assets
COPY --from=builder /app/dist /usr/share/nginx/html

# Copy nginx config
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
</file>

<file path="frontend/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])
</file>

<file path="frontend/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DAGU</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="frontend/package.json">
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tailwindcss/vite": "^4.1.18",
    "@tanstack/react-query": "^5.90.17",
    "axios": "^1.13.2",
    "framer-motion": "^12.26.2",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-router-dom": "^7.12.0",
    "tailwindcss": "^4.1.18"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4"
  }
}
</file>

<file path="frontend/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="frontend/README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```
</file>

<file path="frontend/src/App.css">
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</file>

<file path="frontend/src/App.tsx">
/**
 * MALCHA-DAGU Main App
 */

import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import HomePage from './pages/HomePage';
import SearchResultPage from './pages/SearchResultPage';

// React Query 클라이언트 설정
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5분
      gcTime: 10 * 60 * 1000,   // 10분
      retry: 1,
      refetchOnWindowFocus: false,
    },
  },
});

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <BrowserRouter>
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route path="/search" element={<SearchResultPage />} />
        </Routes>
      </BrowserRouter>
    </QueryClientProvider>
  );
}

export default App;
</file>

<file path="frontend/src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="frontend/src/components/MatchaBounceLoader.tsx">
/**
 * Matcha-Bounce Loader Component
 * 
 * Features:
 * - 최소 1.5초 노출 보장
 * - 단계별 메시지 변경

 * - Bounce 애니메이션
 * - 완료 시 슬라이드 아웃
 */

import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';

interface MatchaBounceLoaderProps {
    isVisible: boolean;
    onComplete?: () => void;
}

const LOADING_MESSAGES = [
    '다구가 기타를 낚아오는 중! 🎣',
    '꼼꼼하게 가격 비교 중... 🧐',
    '다구가 말차 만드는 중... 🍵',
    '거의 다 됐어요! ✨',
];

export default function MatchaBounceLoader({
    isVisible,
    onComplete
}: MatchaBounceLoaderProps) {
    const [messageIndex, setMessageIndex] = useState(0);

    // 단계별 메시지 변경 (0.6초마다)
    useEffect(() => {
        if (!isVisible) {
            setMessageIndex(0);
            return;
        }

        const interval = setInterval(() => {
            setMessageIndex((prev) =>
                prev < LOADING_MESSAGES.length - 1 ? prev + 1 : prev
            );
        }, 1000);

        return () => clearInterval(interval);
    }, [isVisible]);

    return (
        <AnimatePresence onExitComplete={onComplete}>
            {isVisible && (
                <motion.div
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{
                        opacity: 0,
                        y: -100,
                        transition: { duration: 0.4, ease: 'easeInOut' }
                    }}
                    className="fixed inset-0 z-50 flex flex-col items-center justify-center"
                    style={{
                        background: 'linear-gradient(135deg, #f0fdf4 0%, #fffbeb 100%)',
                    }}
                >
                    {/* 배경 원형 글로우 */}
                    <motion.div
                        className="absolute w-64 h-64 rounded-full opacity-30"
                        style={{
                            background: 'radial-gradient(circle, rgba(34, 197, 94, 0.4) 0%, transparent 70%)',
                        }}
                        animate={{
                            scale: [1, 1.2, 1],
                        }}
                        transition={{
                            duration: 2,
                            repeat: Infinity,
                            ease: 'easeInOut',
                        }}
                    />

                    {/* 메인 캐릭터 (찻잔 이모지) */}
                    <motion.div
                        className="text-8xl mb-8 relative z-10"
                        animate={{
                            y: [0, -20, 0],
                        }}
                        transition={{
                            duration: 1,
                            repeat: Infinity,
                            ease: 'easeInOut',
                        }}
                    >
                        🍵
                    </motion.div>

                    {/* 로딩 메시지 */}
                    <motion.div
                        key={messageIndex}
                        initial={{ opacity: 0, y: 10 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: -10 }}
                        transition={{ duration: 0.3 }}
                        className="text-xl font-medium text-stone-700"
                        style={{ fontFamily: 'var(--font-display)' }}
                    >
                        {LOADING_MESSAGES[messageIndex]}
                    </motion.div>

                    {/* 프로그레스 바 */}
                    <div className="mt-8 w-48 h-1.5 bg-stone-200 rounded-full overflow-hidden">
                        <motion.div
                            className="h-full rounded-full"
                            style={{
                                background: 'linear-gradient(90deg, #22c55e 0%, #4ade80 100%)',
                            }}
                            initial={{ width: '0%' }}
                            animate={{ width: '100%' }}
                            transition={{
                                duration: 2.0,
                                ease: 'easeInOut',
                            }}
                        />
                    </div>

                    {/* 브랜드 워터마크 */}
                    <motion.p
                        className="absolute bottom-8 text-sm text-stone-400"
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 0.6 }}
                        transition={{ delay: 0.5 }}
                    >
                        DAGU
                    </motion.p>
                </motion.div>
            )}
        </AnimatePresence>
    );
}
</file>

<file path="frontend/src/components/VSComparisonLayout.tsx">
/**
 * VS Comparison Layout Component
 * 
 * Features:
 * - 좌: 신품 기준가 (Gray tone)
 * - 우: 중고 최저가 리스트 (Accent color)
 * - 반응형 레이아웃
 */

import { motion } from 'framer-motion';
import ItemCard from './ItemCard';
import type { NaverItem, MergedUserItem } from '../types';

interface VSComparisonLayoutProps {
    reference: {
        name: string;
        price: number;
        image_url: string;
    } | null;
    items: (NaverItem | MergedUserItem)[];
    onItemClick?: (item: NaverItem | MergedUserItem) => void;
}

function formatPrice(price: number): string {
    return new Intl.NumberFormat('ko-KR').format(price);
}

export default function VSComparisonLayout({
    reference,
    items,
    onItemClick,
}: VSComparisonLayoutProps) {
    // 상위 5개만 표시
    const topItems = items.slice(0, 5);
    const lowestPrice = topItems[0]?.lprice || 0;
    const savings = reference ? reference.price - lowestPrice : 0;
    const savingsPercent = reference && reference.price > 0
        ? Math.round((savings / reference.price) * 100)
        : 0;

    return (
        <div className="w-full max-w-5xl mx-auto">
            {/* VS 헤더 */}
            <motion.div
                className="flex items-center justify-center gap-4 mb-8"
                initial={{ opacity: 0, y: -20 }}
                animate={{ opacity: 1, y: 0 }}
            >
                <span className="text-stone-400 font-medium">신품</span>
                <div className="w-12 h-12 rounded-full bg-gradient-to-r from-stone-300 to-matcha-400 flex items-center justify-center text-white font-bold text-lg shadow-lg">
                    VS
                </div>
                <span className="text-matcha-600 font-medium">중고</span>
            </motion.div>

            {/* 메인 컨텐츠 */}
            <div className="grid grid-cols-1 lg:grid-cols-12 gap-6 lg:gap-8">
                {/* 좌측: 신품 기준가 */}
                <motion.div
                    className="lg:col-span-4"
                    initial={{ opacity: 0, x: -30 }}
                    animate={{ opacity: 1, x: 0 }}
                    transition={{ delay: 0.1 }}
                >
                    <div className="sticky top-4 p-6 bg-white/50 backdrop-blur-sm rounded-2xl border border-stone-200 shadow-sm">
                        <h3 className="text-sm font-medium text-stone-500 mb-4 uppercase tracking-wider">
                            Reference Price
                        </h3>

                        {reference ? (
                            <>
                                {/* 이미지 */}
                                {reference.image_url && (
                                    <div className="w-full aspect-square rounded-xl overflow-hidden bg-white mb-6 border border-stone-100 shadow-inner">
                                        <img
                                            src={reference.image_url}
                                            alt={reference.name}
                                            className="w-full h-full object-contain p-4 mix-blend-multiply"
                                        />
                                    </div>
                                )}

                                {/* 악기 이름 */}
                                <p className="text-lg font-bold text-stone-800 mb-2 leading-tight">
                                    {reference.name}
                                </p>

                                {/* 가격 */}
                                <p className="text-2xl font-bold text-stone-400 line-through decoration-2 decoration-stone-300/50">
                                    ₩{formatPrice(reference.price)}
                                </p>
                                <p className="text-sm text-stone-400 mt-1">신품 평균가</p>

                                {/* 절약 금액 */}
                                {savings > 0 && (
                                    <motion.div
                                        className="mt-6 p-4 bg-matcha-50 rounded-xl border border-matcha-100 relative overflow-hidden"
                                        initial={{ opacity: 0, scale: 0.9 }}
                                        animate={{ opacity: 1, scale: 1 }}
                                        transition={{ delay: 0.3 }}
                                    >
                                        <div className="absolute top-0 right-0 -mr-4 -mt-4 w-12 h-12 bg-matcha-200 rounded-full blur-xl opacity-50"></div>

                                        <p className="text-sm font-medium text-matcha-800 mb-1">
                                            중고로 구매 시
                                        </p>
                                        <div className="flex items-baseline gap-2">
                                            <p className="text-2xl font-bold text-matcha-600">
                                                {savingsPercent}%
                                            </p>
                                            <span className="text-matcha-600 font-medium">Save</span>
                                        </div>
                                        <p className="text-sm text-matcha-600 mt-0.5 opacity-80">
                                            약 ₩{formatPrice(savings)} 절약
                                        </p>
                                    </motion.div>
                                )}
                            </>
                        ) : (
                            <div className="text-center py-8 text-stone-400">
                                <p className="text-4xl mb-2 opacity-50">📊</p>
                                <p>기준가 정보 없음</p>
                            </div>
                        )}
                    </div>
                </motion.div>

                {/* 우측: 중고 최저가 리스트 */}
                <motion.div
                    className="lg:col-span-8"
                    initial={{ opacity: 0, x: 30 }}
                    animate={{ opacity: 1, x: 0 }}
                    transition={{ delay: 0.2 }}
                >
                    <div className="flex items-center justify-between mb-4 px-1">
                        <h3 className="text-lg font-bold text-stone-800 flex items-center gap-2">
                            <span className="text-2xl">🔥</span> 최저가 TOP {Math.min(topItems.length, 5)}
                        </h3>
                        <span className="text-xs font-medium px-2 py-1 bg-stone-100 rounded-full text-stone-500">
                            총 {items.length}개 매물
                        </span>
                    </div>

                    {topItems.length > 0 ? (
                        <div className="space-y-4">
                            {topItems.map((item, index) => (
                                <ItemCard
                                    key={`item-${index}-${'id' in item ? item.id : item.productId}`}
                                    item={item}
                                    rank={index + 1}
                                    referencePrice={reference?.price}
                                    onClick={() => onItemClick?.(item)}
                                />
                            ))}
                        </div>
                    ) : (
                        <div className="text-center py-16 bg-white/50 border border-dashed border-stone-300 rounded-2xl">
                            <p className="text-4xl mb-4 opacity-50">🎸</p>
                            <p className="text-stone-500 font-medium">검색 결과가 없습니다</p>
                            <p className="text-sm text-stone-400 mt-1">다른 검색어로 시도해보세요</p>
                        </div>
                    )}

                    {/* 더보기 (5개 이상일 때) */}
                    {items.length > 5 && (
                        <motion.button
                            className="w-full mt-6 py-4 text-matcha-700 font-bold bg-white border border-matcha-200 rounded-xl hover:bg-matcha-50 hover:border-matcha-300 transition-all shadow-sm"
                            whileHover={{ scale: 1.01, y: -1 }}
                            whileTap={{ scale: 0.99 }}
                        >
                            + {items.length - 5}개 더보기
                        </motion.button>
                    )}
                </motion.div>
            </div>
        </div>
    );
}
</file>

<file path="frontend/src/hooks/useAuth.ts">
/**
 * SSO 인증 상태 확인 Hook.
 * Dagu 백엔드 API를 통해 HttpOnly 쿠키 인증 상태 확인.
 */

import { useState, useEffect } from 'react';

interface AuthState {
    isLoggedIn: boolean;
    isLoading: boolean;
    userId: number | null;
    username: string | null;
}

/**
 * 로그인 상태 확인 Hook
 * HttpOnly 쿠키는 JS에서 읽을 수 없으므로 백엔드 API로 확인
 */
export function useAuth(): AuthState {
    const [state, setState] = useState<AuthState>({
        isLoggedIn: false,
        isLoading: true,
        userId: null,
        username: null,
    });

    useEffect(() => {
        const checkAuth = async () => {
            try {
                const response = await fetch('/api/auth/check/', {
                    credentials: 'include', // 쿠키 포함 (vite 프록시 경유)
                });

                if (response.ok) {
                    const data = await response.json();
                    setState({
                        isLoggedIn: data.is_authenticated,
                        isLoading: false,
                        userId: data.user_id || null,
                        username: data.username || null,
                    });
                } else {
                    setState({
                        isLoggedIn: false,
                        isLoading: false,
                        userId: null,
                        username: null,
                    });
                }
            } catch (error) {
                console.error('Auth check failed:', error);
                setState({
                    isLoggedIn: false,
                    isLoading: false,
                    userId: null,
                    username: null,
                });
            }
        };

        checkAuth();
    }, []);

    return state;
}

export default useAuth;
</file>

<file path="frontend/src/hooks/useSearch.ts">
/**
 * React Query hooks for MALCHA-DAGU
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import * as api from '../services/api';
import type { SearchResult } from '../types';

// =============================================================================
// Search Hook
// =============================================================================

export function useSearch(query: string, options?: { enabled?: boolean }) {
    return useQuery<SearchResult>({
        queryKey: ['search', query],
        queryFn: () => api.search(query),
        enabled: options?.enabled ?? query.length > 0,
        staleTime: 5 * 60 * 1000, // 5분간 캐시 유지
        gcTime: 10 * 60 * 1000, // 10분간 가비지 컬렉션 방지
    });
}

// =============================================================================
// Instruments Hook
// =============================================================================

export function useInstruments(params?: {
    brand?: string;
    category?: string;
    search?: string;
}) {
    return useQuery({
        queryKey: ['instruments', params],
        queryFn: () => api.getInstruments(params),
    });
}

export function useInstrument(id: string) {
    return useQuery({
        queryKey: ['instrument', id],
        queryFn: () => api.getInstrument(id),
        enabled: !!id,
    });
}

// =============================================================================
// User Items Hook
// =============================================================================

export function useUserItems(params?: {
    instrument?: string;
    source?: string;
    min_price?: number;
    max_price?: number;
}) {
    return useQuery({
        queryKey: ['userItems', params],
        queryFn: () => api.getUserItems(params),
    });
}

export function useCreateUserItem() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: api.createUserItem,
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['userItems'] });
            queryClient.invalidateQueries({ queryKey: ['search'] });
        },
    });
}

export function useTrackItemClick() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: api.trackItemClick,
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['userItems'] });
        },
    });
}

export function useExtendUserItem() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: api.extendUserItem,
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['search'] });
            queryClient.invalidateQueries({ queryKey: ['userItems'] });
        },
    });
}

// =============================================================================
// AI Description Hook
// =============================================================================

export function useAIDescription() {
    return useMutation({
        mutationFn: api.getAIDescription,
    });
}
</file>

<file path="frontend/src/index.css">
@import "tailwindcss";

@theme {
  /* Matcha Green Palette */
  --color-matcha-50: #f0fdf4;
  --color-matcha-100: #dcfce7;
  --color-matcha-200: #bbf7d0;
  --color-matcha-300: #86efac;
  --color-matcha-400: #4ade80;
  --color-matcha-500: #22c55e;
  --color-matcha-600: #16a34a;
  --color-matcha-700: #15803d;
  --color-matcha-800: #166534;
  --color-matcha-900: #14532d;

  /* Cream/Warm Palette */
  --color-cream-50: #fffbeb;
  --color-cream-100: #fef3c7;
  --color-cream-200: #fde68a;
  --color-cream-300: #fcd34d;

  /* Fonts */
  --font-display: 'Outfit', sans-serif;
  --font-body: 'Inter', sans-serif;
}

/* =============================================================================
   Base Layer
   ============================================================================= */
@layer base {
  html {
    scroll-behavior: smooth;
  }

  body {
    font-family: var(--font-body);
    background: linear-gradient(135deg, var(--color-matcha-50) 0%, var(--color-cream-50) 100%);
    min-height: 100vh;
    color: var(--color-stone-800);
    @apply antialiased;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-family: var(--font-display);
    @apply font-semibold leading-tight;
  }
}

/* =============================================================================
   Utilities Layer
   ============================================================================= */
@layer utilities {
  .text-gradient {
    background: linear-gradient(135deg, var(--color-matcha-600) 0%, var(--color-matcha-400) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .glass {
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(12px);
    border: 1px solid rgba(255, 255, 255, 0.3);
  }

  .glass-dark {
    background: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(12px);
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  /* Scrollbar */
  .scrollbar-custom::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }

  .scrollbar-custom::-webkit-scrollbar-track {
    @apply bg-stone-100;
  }

  .scrollbar-custom::-webkit-scrollbar-thumb {
    @apply bg-matcha-400 rounded-full;
  }

  .scrollbar-custom::-webkit-scrollbar-thumb:hover {
    @apply bg-matcha-500;
  }
}

/* =============================================================================
   Components Layer (Animations)
   ============================================================================= */
@layer components {

  /* Using standard tailwind animation utilities where possible, extending custom ones */
  @keyframes bounce-soft {

    0%,
    100% {
      transform: translateY(0);
    }

    50% {
      transform: translateY(-12px);
    }
  }

  @keyframes pulse-glow {

    0%,
    100% {
      box-shadow: 0 0 20px rgba(34, 197, 94, 0.3);
    }

    50% {
      box-shadow: 0 0 40px rgba(34, 197, 94, 0.5);
    }
  }

  @keyframes slide-up {
    from {
      opacity: 0;
      transform: translateY(20px);
    }

    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .animate-bounce-soft {
    animation: bounce-soft 2s ease-in-out infinite;
  }

  .animate-pulse-glow {
    animation: pulse-glow 2s ease-in-out infinite;
  }

  .animate-slide-up {
    animation: slide-up 0.5s ease-out forwards;
  }
}
</file>

<file path="frontend/src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path="frontend/src/types/index.ts">
/**
 * Type definitions for MALCHA-DAGU
 */

// =============================================================================
// API Response Types
// =============================================================================

export interface Instrument {
    id: string;
    name: string;
    brand: string;
    category: string;
    category_display: string;
    image_url: string;
    reference_price: number;
    description: string;
    created_at: string;
    updated_at: string;
}

export interface UserItem {
    id: string;
    instrument: string;
    instrument_detail: {
        id: string;
        name: string;
        brand: string;
        image_url: string;
        reference_price: number;
    };
    price: number;
    link: string;
    source: string;
    source_display: string;
    title: string;
    is_active: boolean;
    expired_at: string;
    extended_at: string | null;
    click_count: number;
    discount_rate: number;
    is_expired: boolean;
    is_owner: boolean;
    owner_id: number | null;
    created_at: string;
    updated_at: string;
}

export interface NaverItem {
    title: string;
    link: string;
    image: string;
    lprice: number;
    hprice: number;
    mallName: string;
    productId: string;
    productType: number;
    source: 'naver';
}

export interface SearchResult {
    query: string;
    total_count: number;
    reference: {
        name: string;
        price: number;
        image_url: string;
    } | null;
    items: (NaverItem | MergedUserItem)[];
    naver_items: NaverItem[];
    user_items: MergedUserItem[];
}

export interface MergedUserItem {
    id: string;
    title: string;
    link: string;
    image: string;
    lprice: number;
    source: string;
    source_display: string;
    discount_rate: number;
    instrument_id: string;
    instrument_name: string;
    instrument_brand: string;
    owner_id: number | null;
    extended_at: string | null;
}

export interface AIDescription {
    summary: string;
    check_point: string;
}

// =============================================================================
// Component Props Types
// =============================================================================

export interface SearchBarProps {
    onSearch: (query: string) => void;
    isLoading?: boolean;
    placeholder?: string;
}

export interface ItemCardProps {
    item: NaverItem | MergedUserItem;
    rank?: number;
    referencePrice?: number;
    onClick?: () => void;
    isOwner?: boolean;
    onExtend?: () => void;
}

export interface LoaderProps {
    isVisible: boolean;
    onComplete?: () => void;
}
</file>

<file path="frontend/tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="frontend/tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="frontend/tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="run_server.bat">
@echo off
REM MALCHA-DAGU 개발 서버 실행 스크립트
REM 포트: 127.0.0.1:8001

cd /d "%~dp0backend"
python manage.py runserver 127.0.0.1:8001
</file>

<file path="backend/config/settings.py">
"""
Django settings for MALCHA-DAGU project.
Production-ready configuration with environment variables.
"""

import os
from datetime import timedelta
from pathlib import Path

import environ

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Initialize environ
env = environ.Env(
    DEBUG=(bool, False),
    ALLOWED_HOSTS=(list, ['localhost', '127.0.0.1']),
)

# Read .env file if it exists
env_file = BASE_DIR.parent / '.env'
if env_file.exists():
    environ.Env.read_env(str(env_file))

# =============================================================================
# Core Settings
# =============================================================================

# SSO: Malcha와 동일한 SECRET_KEY 사용 (JWT 서명 검증)
# 프로덕션에서는 SHARED_SECRET_KEY 환경변수 필수
SECRET_KEY = env('SHARED_SECRET_KEY', default=env('SECRET_KEY', default='django-insecure-dev-key-change-in-production'))
DEBUG = env('DEBUG')
ALLOWED_HOSTS = env('ALLOWED_HOSTS')

# =============================================================================
# Application definition
# =============================================================================

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Third-party
    'rest_framework',
    'rest_framework_simplejwt',  # SSO: JWT 검증
    'corsheaders',
    # Local apps
    'dagu',
]

# Add celery beat if available (production)
try:
    import django_celery_beat
    INSTALLED_APPS.append('django_celery_beat')
except ImportError:
    pass

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',  # Must be before CommonMiddleware
    'django.middleware.security.SecurityMiddleware',
    'config.middleware.SecurityHeadersMiddleware',  # 커스텀 보안 헤더
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'config.middleware.RequestLoggingMiddleware',  # 보안 로깅
]

ROOT_URLCONF = 'config.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'

# =============================================================================
# Database
# =============================================================================

# Use DATABASE_URL if available, otherwise default to SQLite for development
DATABASES = {
    'default': env.db('DATABASE_URL', default=f'sqlite:///{BASE_DIR / "db.sqlite3"}')
}

# =============================================================================
# Cache (Redis or Local Memory)
# =============================================================================

REDIS_URL = env('REDIS_URL', default='redis://localhost:6379/0')

# Use Redis if available, otherwise fallback to local memory cache
try:
    import django_redis
    CACHES = {
        'default': {
            'BACKEND': 'django_redis.cache.RedisCache',
            'LOCATION': REDIS_URL,
            'OPTIONS': {
                'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            }
        }
    }
except ImportError:
    CACHES = {
        'default': {
            'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
            'LOCATION': 'unique-snowflake',
        }
    }

# =============================================================================
# Celery Configuration
# =============================================================================

CELERY_BROKER_URL = REDIS_URL
CELERY_RESULT_BACKEND = REDIS_URL
CELERY_ACCEPT_CONTENT = ['json']
CELERY_TASK_SERIALIZER = 'json'
CELERY_RESULT_SERIALIZER = 'json'
CELERY_TIMEZONE = 'Asia/Seoul'
CELERY_BEAT_SCHEDULER = 'django_celery_beat.schedulers:DatabaseScheduler'

# =============================================================================
# REST Framework
# =============================================================================

REST_FRAMEWORK = {
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework.renderers.JSONRenderer',
    ],
    'DEFAULT_PARSER_CLASSES': [
        'rest_framework.parsers.JSONParser',
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 20,
    # Rate Limiting (프로덕션 환경에서 API 남용 방지)
    'DEFAULT_THROTTLE_CLASSES': [
        'rest_framework.throttling.AnonRateThrottle',
        'rest_framework.throttling.UserRateThrottle',
    ],
    'DEFAULT_THROTTLE_RATES': {
        'anon': '100/hour',      # 비인증 사용자: 시간당 100회
        'user': '1000/hour',     # 인증 사용자: 시간당 1000회
        'search': '60/minute',   # 검색 API: 분당 60회
    },
    # 전역 예외 핸들러 (표준화된 에러 응답)
    'EXCEPTION_HANDLER': 'dagu.exceptions.custom_exception_handler',
}

# Add BrowsableAPI in debug mode
if DEBUG:
    REST_FRAMEWORK['DEFAULT_RENDERER_CLASSES'].append(
        'rest_framework.renderers.BrowsableAPIRenderer'
    )

# =============================================================================
# SSO: JWT 쿠키 인증 설정 (Malcha 발급 JWT 검증)
# =============================================================================

# 서브도메인 쿠키 공유를 위한 도메인 설정 (점(.) 접두사 필수)
COOKIE_DOMAIN = '.malchalab.com' if not DEBUG else None

# SimpleJWT 설정 (Malcha와 동일한 설정으로 검증)
SIMPLE_JWT = {
    "ACCESS_TOKEN_LIFETIME": timedelta(minutes=30),
    "REFRESH_TOKEN_LIFETIME": timedelta(days=7),
    "ALGORITHM": "HS256",
    "SIGNING_KEY": SECRET_KEY,  # Malcha와 동일한 키
    "AUTH_HEADER_TYPES": ("Bearer",),
    # SSO: Malcha가 발급한 쿠키명
    "AUTH_COOKIE": "malcha-access-token",
    "AUTH_COOKIE_DOMAIN": COOKIE_DOMAIN,
    "AUTH_COOKIE_SECURE": not DEBUG,
    "AUTH_COOKIE_HTTP_ONLY": True,
    "AUTH_COOKIE_SAMESITE": "Lax",

    # SSO 보안: 토큰 발급자/수신자 검증 (Malcha 설정과 일치해야 함)
    "ISSUER": "malchalab.com",  # 토큰 발급자 검증
    "AUDIENCE": "dagu.malchalab.com",  # Dagu가 허용된 수신자인지 확인

    # 추가 보안 설정
    "JTI_CLAIM": "jti",
    "TOKEN_TYPE_CLAIM": "token_type",
    "USER_ID_CLAIM": "user_id",
}

# JWT 쿠키 인증 클래스 추가
REST_FRAMEWORK['DEFAULT_AUTHENTICATION_CLASSES'] = [
    'dagu.authentication.JWTCookieAuthentication',
]

# =============================================================================
# CORS Settings
# =============================================================================

# 환경 변수에서 CORS 도메인 로드 (쉼표로 구분)
# 예: CORS_ORIGINS=https://example.com,https://www.example.com
_cors_origins_env = env('CORS_ORIGINS', default='')
_cors_origins_from_env = [origin.strip() for origin in _cors_origins_env.split(',') if origin.strip()]

# 기본 개발 환경 도메인 + 환경 변수 도메인
CORS_ALLOWED_ORIGINS = [
    'http://localhost:3000',
    'http://localhost:5173',
    'http://127.0.0.1:3000',
    'http://127.0.0.1:5173',
] + _cors_origins_from_env

# 프로덕션 환경에서는 개발 도메인 제거
if not DEBUG:
    CORS_ALLOWED_ORIGINS = _cors_origins_from_env if _cors_origins_from_env else CORS_ALLOWED_ORIGINS

CORS_ALLOW_CREDENTIALS = True

# CORS preflight 캐싱 (성능 최적화)
CORS_PREFLIGHT_MAX_AGE = 86400  # 24시간

# =============================================================================
# Password validation
# =============================================================================

AUTH_PASSWORD_VALIDATORS = [
    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},
    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},
    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},
    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},
]

# =============================================================================
# Internationalization
# =============================================================================

LANGUAGE_CODE = 'ko-kr'
TIME_ZONE = 'Asia/Seoul'
USE_I18N = True
USE_TZ = True

# =============================================================================
# Static files
# =============================================================================

STATIC_URL = 'static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'

# =============================================================================
# Default primary key field type
# =============================================================================

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# =============================================================================
# External API Keys
# =============================================================================

NAVER_CLIENT_ID = env('NAVER_CLIENT_ID', default='')
NAVER_CLIENT_SECRET = env('NAVER_CLIENT_SECRET', default='')
OPENAI_API_KEY = env('OPENAI_API_KEY', default='')

# =============================================================================
# Security Settings (Production)
# =============================================================================

# SSO: 서브도메인 쿠키 공유
SESSION_COOKIE_DOMAIN = COOKIE_DOMAIN
CSRF_COOKIE_DOMAIN = COOKIE_DOMAIN

# CSRF 신뢰 출처 (SSO)
if DEBUG:
    CSRF_TRUSTED_ORIGINS = [
        'http://localhost:5173', 'http://127.0.0.1:5173',  # Malcha frontend
        'http://localhost:3000', 'http://127.0.0.1:3000',  # Dagu frontend
    ]
else:
    CSRF_TRUSTED_ORIGINS = [
        'https://malchalab.com',
        'https://www.malchalab.com',
        'https://dagu.malchalab.com',
    ]

if not DEBUG:
    # HTTPS 강제
    SECURE_SSL_REDIRECT = True
    SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')

    # HSTS (HTTP Strict Transport Security)
    SECURE_HSTS_SECONDS = 31536000  # 1년
    SECURE_HSTS_INCLUDE_SUBDOMAINS = True
    SECURE_HSTS_PRELOAD = True

    # Cookie 보안
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True
    SESSION_COOKIE_HTTPONLY = True
    CSRF_COOKIE_HTTPONLY = True

    # XSS 방지
    SECURE_BROWSER_XSS_FILTER = True
    SECURE_CONTENT_TYPE_NOSNIFF = True

    # Clickjacking 방지
    X_FRAME_OPTIONS = 'DENY'

# =============================================================================
# Logging
# =============================================================================

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
    },
    'root': {
        'handlers': ['console'],
        'level': 'INFO',
    },
    'loggers': {
        'dagu': {
            'handlers': ['console'],
            'level': 'DEBUG',
            'propagate': False,
        },
        'dagu.services': {
            'handlers': ['console'],
            'level': 'INFO',
            'propagate': False,
        },
        'dagu.filters': {
            'handlers': ['console'],
            'level': 'DEBUG',  # 필터 탈락 로그 활성화
            'propagate': False,
        },
    },
}
</file>

<file path="backend/dagu/config.py">
"""
Filter configuration for MALCHA-DAGU.
Based on proven filtering patterns for instrument search quality.
"""


class CrawlerConfig:
    """크롤러/API 설정"""
    
    # 가격 설정
    MIN_PRICE_KRW = 200000  # 20만원 (악기 기본)
    MIN_PRICE_PEDAL = 50000 # 5만원 (이펙터/액세서리)
    MIN_PRICE_USD = 100
    
    # 결과 개수 설정
    MAX_RESULTS_NAVER = 20
    MAX_RESULTS_USER = 20
    
    # 타임아웃
    TIMEOUT_NAVER = 5


class CategoryConfig:
    """카테고리 판별용 키워드"""

    GUITAR_BRANDS = ["fender", "gibson", "prs", "ibanez", "esp", "jackson", "gopherwood", "swing"]
    BASS_KEYWORDS = ['bass', 'precision', 'jazz bass', 'pbass', 'jbass']

    # =========================================================================
    # 모델명 별칭 매핑 (검색어 → 정식 모델명)
    # 검색 시 별칭을 정식 모델명으로 변환하여 DB 매칭 정확도 향상
    # =========================================================================
    MODEL_ALIASES = {
        # BOSS 이펙터
        'ds1': 'DS-1',
        'ds-1': 'DS-1',
        'ds2': 'DS-2',
        'sd1': 'SD-1',
        'bd2': 'BD-2',
        'mt2': 'MT-2',
        'ce5': 'CE-5',
        'dd8': 'DD-8',
        'rv6': 'RV-6',
        'tu3': 'TU-3',
        'rc5': 'RC-5',
        'katana': 'KATANA',

        # Fender 기타
        'strat': 'Stratocaster',
        'stratocaster': 'Stratocaster',
        'tele': 'Telecaster',
        'telecaster': 'Telecaster',
        'jazzmaster': 'Jazzmaster',
        'jaguar': 'Jaguar',
        'mustang': 'Mustang',

        # Gibson 기타
        'lp': 'Les Paul',
        'lespaul': 'Les Paul',
        'les paul': 'Les Paul',
        'sg': 'SG',
        'es335': 'ES-335',
        'es-335': 'ES-335',
        'flying v': 'Flying V',
        'explorer': 'Explorer',

        # 베이스
        'pbass': 'Precision Bass',
        'p-bass': 'Precision Bass',
        'precision': 'Precision Bass',
        'jbass': 'Jazz Bass',
        'j-bass': 'Jazz Bass',

        # Ibanez
        'rg': 'RG',
        'jem': 'JEM',
        'prestige': 'Prestige',
        'ts9': 'TS9',
        'ts808': 'TS808',
        'tubescreamer': 'Tube Screamer',
        'tube screamer': 'Tube Screamer',

        # PRS
        'custom24': 'Custom 24',
        'custom 24': 'Custom 24',
        'mccarty': 'McCarty',
        'se': 'SE',

        # Marshall
        'jcm800': 'JCM800',
        'jcm900': 'JCM900',
        'dsl': 'DSL',
        'plexi': 'Plexi',
    }
    # 페달 키워드 (브랜드 + 모델명 패턴 + 한글)
    PEDAL_KEYWORDS = [
        'pedal', 'stomp', 'effect', 'effects', 'effector', '이펙터', '페달',
        # 브랜드
        'boss', '보스', 'strymon', 'tc electronic', 'mxr', 'electro-harmonix', 'ehx',
        'ibanez tube screamer', 'ts808', 'ts9', 'keeley', 'walrus audio', 'jhs',
        # 이펙트 종류
        'overdrive', 'distortion', 'fuzz', 'delay', 'reverb', 'chorus', 'phaser',
        'flanger', 'compressor', 'wah', 'looper', 'tuner pedal', 'eq pedal',
        'booster', 'octave', 'tremolo', 'vibrato', 'noise gate', 'preamp pedal',
        # BOSS 모델명 패턴 (대표적인 것들)
        'ds-1', 'ds-2', 'sd-1', 'bd-2', 'od-3', 'mt-2', 'hm-2', 'md-2',
        'ce-5', 'ch-1', 'bf-3', 'ph-3', 'rv-6', 'dd-8', 'rc-5', 'tu-3',
        'ad-2', 'ad-3', 'cs-3', 'ge-7', 'ns-2', 'ps-6', 'sy-1', 'oc-5',
    ]
    AMP_KEYWORDS = ['amp', 'cabinet', 'head', 'combo', 'amplifier']
    ACOUSTIC_KEYWORDS = ['acoustic', 'martin', 'taylor', '어쿠스틱', '통기타']

    # 한글 브랜드명 매핑 (한글 검색 -> 영문 브랜드 감지용)
    BRAND_NAME_MAPPING = {
        '펜더': 'fender', '팬더': 'fender',
        '깁슨': 'gibson',
        '피알에스': 'prs',
        '아이바네즈': 'ibanez', '이바네즈': 'ibanez',
        '이에스피': 'esp',
        '잭슨': 'jackson',
        '샤벨': 'charvel',
        '쉑터': 'schecter',
        '써': 'suhr',
        '뮤직맨': 'musicman',
        '지앤엘': 'g&l', '지엔엘': 'g&l',
        '야마하': 'yamaha',
        '크래머': 'kramer',
        '그레치': 'gretsch',
        '보스': 'boss',
        '마샬': 'marshall',
        '복스': 'vox',
        '오렌지': 'orange',
        '메사': 'mesa',
        '고퍼우드': 'gopherwood',
        '스윙': 'swing',
    }
    
  

class FilterConfig:
    """필터링 설정"""

    # =========================================================================
    # [0] 블랙리스트 예외 키워드 (이 단어가 있으면 블랙리스트 무시)
    # "본품 + 액세서리 세트"는 본품이므로 통과시킴
    # =========================================================================
    BLACKLIST_EXCEPTION_KEYWORDS = [
        '세트', '동시 구매', '동시구매', '포함', '증정', '사은품',
        'set', 'bundle', 'combo', 'package', 'included', 'with',
    ]

    # =========================================================================
    # [1] 통합 블랙리스트 (이 단어가 제목에 있으면 무조건 제외)
    # =========================================================================
    BLACKLIST_KEYWORDS = [
        # 1. 상태/조건 (영문)
        'case only', 'empty', 'neck only', 'body only', 'parts only', 
        'box only', 'damaged', 'broken', 'for parts',
        
        # 2. 부품류 (영문)
        'neck', 'body', 'pickup', 'pickups', 'knob', 'knobs',
        'bridge', 'potentiometer', 'pot', 'pots',
        'part', 'parts', 'screw', 'screws', 'saddle',
        'wiring', 'truss rod', 'pickguard', 'switch', 'tuner', 'tuners',
        'cover', 'covers', 'plate', 'assembly', 'electronics', '픽업',
        
        # 2-1. 부품류 (한글)
        '넥', '넥만', '바디', '바디만', '픽업', '노브', '브릿지', '브리지',
        '부품', '나사', '너트', '키트', '조립', '배선', '픽가드', '스위치',
        '튜너', '커버', '덮개', '회로', '스피커', '알루미늄', '툴', '아노다이징', '튜닝', '본체',
        
        # 3. 액세서리류 (영문)
        'case', 'bag', 'gig bag', 'hardcase', 'strap', 'cable',
        'capo', 'hanger', 'sticker', 'picks', 'slide',
        'string', 'polish', 'cloth', 'mini', '미니', 'adapter', '모자', '자전거',  # '손잡이' 제거 (왼손잡이 기타 오탐 방지)
        
        # 3-1. 액세서리류 (한글)
        '케이스', '가방', '하드케이스', '긱백', '스트랩', '케이블',
        '카포', '스탠드', '거치대', '슬라이드', '줄', '어댑터',
        
        # 4. 문서/잡동사니
        'manual', 'instruction', 'warranty', 'certificate', 'book',
        'logo', 'decal', 'poster', 'catalog',
        '설명서', '메뉴얼', '보증서', '교본', '로고', '포스터',
        
        # 5. 짝퉁/복제품
        'copy', 'replica', 'clone', 'fake', 'style', 'type',
        '복사', '복제', '모조', '짝퉁', '카피', '레플리카', '미니어처',
        
        # 6. 불량/파손
        '파손', '고장', '불량', '흠집', '부러짐', '깨짐', 'junk'
    ]
    
    # =========================================================================
    # [2] 브랜드 하이어라키 (상위 브랜드 검색 시 하위 브랜드 제외)
    # =========================================================================
    BRAND_HIERARCHY = {
        'fender': [
            'squier', 'squire', 'affinity', 'bullet', 'sonic',
            'classic vibe', 'cv', 'paranormal', 'contemporary',
            'fender clone', 'copy', 'replica', 'mini', 'loog', '스콰이어', '스퀴어',
        ],
        'gibson': [
            'epiphone', 'maestro', 'baldwin', 'kramer',
            'gibson style', 'gibson copy', 'replica', 'chibson', '에피폰',
        ],
        'prs': ['se', 's2', 'student edition'],
        'esp': ['ltd', 'edwards', 'grassroots'],
        'musicman': ['sterling', 'sub', 's.u.b'],
        'g&l': ['tribute'],
        'lakland': ['skyline'],
    }
    
    # =========================================================================
    # [3] 토큰 동의어 (모델명 매칭 확장)
    # =========================================================================
    TOKEN_SYNONYMS = {
        'stratocaster': ['strat', 'st'],
        'telecaster': ['tele', 'tl'],
        'les paul': ['lp', 'lespaul'],
        'precision': ['pbass', 'p-bass', 'p bass'],
        'jazz bass': ['jbass', 'j-bass', 'j bass'],
        'mexico': ['mexico', 'mexican', 'mim', 'player'],
        'japan': ['japan', 'japanese', 'mij', 'cij'],
        'usa': ['usa', 'american', 'mia'],
        'custom': ['custom', 'cs', 'masterbuilt'],
    }
    
    # =========================================================================
    # [4] 카테고리 불일치 필터 키워드
    # =========================================================================
    
    # 기타/베이스 검색 시 페달 제외용
    CATEGORY_PEDAL_KEYWORDS = [
        'pedal', 'stomp', 'stompbox', 'effect', 'effects', 'fx',
        'overdrive', 'distortion', 'fuzz', 'boost', 'booster',
        'delay', 'reverb', 'echo', 'chorus', 'flanger', 'phaser',
        'tremolo', 'vibrato', 'compressor', 'limiter',
        'wah', 'wah-wah', 'octave', 'harmonizer',
        'eq', 'equalizer', 'looper', 'multi-effect', 'pedalboard',
        '페달', '이펙터', '이펙트', '스톰프',
        '오버드라이브', '디스토션', '퍼즈', '부스터',
        '딜레이', '리버브', '코러스', '컴프레서', '와우', '루퍼',
    ]
    
    # 기타/베이스 검색 시 앰프 제외용
    CATEGORY_AMP_KEYWORDS = [
        'amplifier', 'amp', 'amp head', 'combo', 'combo amp',
        'cabinet', 'cab', 'head', 'stack', 'half stack', 'full stack',
        'rumble', 'bassman', 'twin reverb', 'deluxe reverb',  # 'deluxe' 단독 제거 (Les Paul Deluxe 오탐 방지)
        'princeton', 'champ', 'super', 'vibrolux',
        'marshall', 'vox', 'orange', 'mesa', 'boogie', 'peavey', 'ampeg',
        'roland', 'boss katana', 'blackstar',
        '앰프', '콤보', '콤보앰프', '캐비넷', '헤드앰프', '스택',
    ]
    
    # 페달 검색 시 기타/베이스 본체 제외용
    CATEGORY_INSTRUMENT_KEYWORDS = [
        'electric guitar', 'acoustic guitar', 'bass guitar',
        '일렉기타', '일렉트릭 기타', '어쿠스틱', '베이스기타',
    ]
    
    # BASS/GUITAR 검색 시 어쿠스틱 제외용
    CATEGORY_ACOUSTIC_KEYWORDS = [
        'acoustic bass', 'acoustic-electric bass', 'semi-acoustic bass',
        'hollow body bass', 'semi-hollow bass',
        'acoustic guitar', 'acoustic-electric', 'semi-acoustic',
        'hollow body', 'semi-hollow',
        '어쿠스틱베이스', '어쿠스틱 베이스', '통베이스',
        '어쿠스틱기타', '어쿠스틱 기타', '통기타',
    ]
    
    # =========================================================================
    # [5] 쿼리 제외 키워드 (API 요청 시 쿼리에 -키워드 추가)
    # =========================================================================
    QUERY_EXCLUSION_KEYWORDS = [
        # 전원/케이블류
        '어댑터', '아답터', '케이블', '파워', '전원',
        # 부품류
        '노브', '잭', '브릿지', '픽업', '새들',
        # 악세서리류
        '스트랩', '케이스', '가방', '거치대',
        # 기타
        '스티커', '배터리', '충전기',
    ]
    
    # =========================================================================
    # [6] 액세서리 카테고리 (category3, category4에서 제외할 카테고리)
    # =========================================================================
    ACCESSORY_CATEGORY_BLACKLIST = [
        # category4 값으로 자주 오는 액세서리 분류
        '악기부품', '기타부품', '베이스부품', '부품',
        '악기케이블', '케이블', '음향케이블',
        '기타액세서리', '베이스액세서리', '악세사리', '액세서리',
        '기타케이스', '베이스케이스', '하드케이스', '긱백',
        '기타스탠드', '악기스탠드', '거치대',
        '기타스트랩', '스트랩',
        '기타줄', '베이스줄', '현', '스트링',
        '기타픽', '피크', '픽',
        '기타카포', '카포',
        '어댑터', '전원장치', '파워서플라이',
    ]
    
    # =========================================================================
    # [7] 유효한 악기 카테고리 (이 카테고리면 '본품'으로 간주)
    # =========================================================================
    VALID_INSTRUMENT_CATEGORIES = {
        # 기타류
        'guitar': ['일렉기타', '일렉트릭기타', '어쿠스틱기타', '클래식기타', '기타'],
        'bass': ['베이스기타', '일렉트릭베이스', '어쿠스틱베이스', '베이스'],
        'pedal': ['이펙터', '기타이펙터', '베이스이펙터', '멀티이펙터', '페달'],
        'amp': ['기타앰프', '베이스앰프', '앰프', '콤보앰프', '앰프헤드'],
    }
    
    # =========================================================================
    # [8] productType 필터 (상품 타입별 신뢰도)
    # =========================================================================
    # 1: 일반상품(가격비교O), 2: 일반상품(가격비교X), 3: 일반상품(가격비교 매칭)
    # 4: 중고상품, 5: 단종상품, 6: 판매예정상품
    VALID_PRODUCT_TYPES = [1, 2, 3]  # 중고(4), 단종(5), 판매예정(6) 제외
</file>

<file path="backend/dagu/filters.py">
"""
Filter utilities for MALCHA-DAGU.
Quality filtering functions for search results.
"""

import logging
import re
from functools import lru_cache
from typing import Optional

from .config import FilterConfig, CategoryConfig, CrawlerConfig

# =============================================================================
# 사용자 매물 필터링
# =============================================================================

def filter_user_item(
    title: str,
    price: int,
    category: str = None,
    min_price: int = None,
) -> bool:
    """
    사용자 매물 필터링.
    유저가 직접 등록한 매물이므로 가격 필터는 적용하지 않음.

    Returns:
        True = 통과, False = 탈락
    """
    # [필터 1] 블랙리스트
    if not check_blacklist(title):
        return False

    # [필터 2] 카테고리 불일치 (카테고리가 주어진 경우)
    if category and not check_category_mismatch(category, title):
        return False

    return True

logger = logging.getLogger(__name__)


# =============================================================================
# 필터 통계 (디버깅용)
# =============================================================================

class FilterStats:
    """필터 통계 추적 (디버깅용)"""

    def __init__(self):
        self.reset()

    def reset(self):
        self.total = 0
        self.passed = 0
        self.failed_by = {
            'price': 0,
            'blacklist': 0,
            'brand': 0,
            'category': 0,
            'category_fields': 0,
            'product_type': 0,
        }

    def record_pass(self):
        self.total += 1
        self.passed += 1

    def record_fail(self, reason: str):
        self.total += 1
        if reason in self.failed_by:
            self.failed_by[reason] += 1

    def log_summary(self, prefix: str = ""):
        if self.total == 0:
            return
        logger.info(
            f"{prefix}[FilterStats] 총 {self.total}개 중 {self.passed}개 통과 "
            f"({self.passed/self.total*100:.1f}%)"
        )
        for reason, count in self.failed_by.items():
            if count > 0:
                logger.debug(f"  - {reason}: {count}개 탈락")


# 전역 통계 인스턴스 (선택적 사용)
_filter_stats = FilterStats()


# =============================================================================
# 블랙리스트 로딩 (캐싱으로 성능 최적화)
# =============================================================================

@lru_cache(maxsize=1)
def get_blacklist() -> tuple[str, ...]:
    """
    블랙리스트 로드 및 정규화 (캐싱 적용).
    - 소문자 변환
    - 중복 제거
    - 비정상적으로 긴 단어 경고
    - lru_cache로 앱 시작 시 1회만 처리

    Returns:
        tuple[str, ...]: 캐싱을 위해 불변 tuple 반환
    """
    raw_list = getattr(FilterConfig, 'BLACKLIST_KEYWORDS', [])

    if not raw_list:
        logger.warning("BLACKLIST_KEYWORDS가 비어있습니다.")
        return tuple()

    result = set()
    for item in raw_list:
        if item:
            word = str(item).strip().lower()
            # 비정상적으로 긴 단어 감지 (쉼표 누락으로 문자열 결합된 경우)
            if len(word) > 25:
                logger.warning(f"블랙리스트에 비정상적으로 긴 단어 발견: '{word}'")
            result.add(word)

    logger.info(f"블랙리스트 로드 완료: {len(result)}개 키워드")
    return tuple(result)


def clear_blacklist_cache():
    """블랙리스트 캐시 초기화 (설정 변경 시 호출)"""
    get_blacklist.cache_clear()


# =============================================================================
# 필터 함수들
# =============================================================================

def _is_korean(text: str) -> bool:
    """한글 포함 여부 확인"""
    return any('\uac00' <= char <= '\ud7a3' for char in text)


@lru_cache(maxsize=1)
def get_blacklist_exceptions() -> tuple[str, ...]:
    """블랙리스트 예외 키워드 로드 (캐싱)"""
    raw_list = getattr(FilterConfig, 'BLACKLIST_EXCEPTION_KEYWORDS', [])
    return tuple(word.lower() for word in raw_list if word)


def check_blacklist(title: str) -> bool:
    """
    블랙리스트 검사.
    - 예외 키워드(세트, 포함 등)가 있으면 블랙리스트 무시
    - 영어 키워드: 단어 경계 검사 (word boundary)
    - 한글 키워드: 부분문자열 매칭

    Returns:
        True = 통과 (블랙리스트에 없음)
        False = 탈락 (블랙리스트에 있음)
    """
    title_lower = title.lower()

    # 예외 키워드 확인 ("세트", "동시 구매" 등이 있으면 블랙리스트 무시)
    exceptions = get_blacklist_exceptions()
    if any(exc in title_lower for exc in exceptions):
        logger.debug(f"[Blacklist] 예외 통과 (세트/포함): {title[:50]}")
        return True

    current_blacklist = get_blacklist()

    for blackword in current_blacklist:
        if _is_korean(blackword):
            # 한글: 부분문자열 매칭
            if blackword in title_lower:
                logger.debug(f"[Blacklist] 탈락: '{blackword}' - {title[:50]}")
                return False
        else:
            # 영어: 단어 경계 검사 (앞뒤로 알파벳이 아닌 문자)
            pattern = rf'(?<![a-zA-Z]){re.escape(blackword)}(?![a-zA-Z])'
            if re.search(pattern, title_lower):
                logger.debug(f"[Blacklist] 탈락: '{blackword}' - {title[:50]}")
                return False

    return True


def check_min_price(price: int, min_price: int = None) -> bool:
    """
    최소 가격 검사.
    부품/케이스 등 너무 싼 물건 제외.
    
    Returns:
        True = 통과
        False = 탈락
    """
    if min_price is None:
        min_price = CrawlerConfig.MIN_PRICE_KRW
    
    if price < min_price:
        logger.debug(f"[PriceFilter] 탈락: {price:,}원 < {min_price:,}원")
        return False
    
    return True


def check_brand_integrity(target_brand: str, title: str) -> bool:
    """
    브랜드 무결성 검사.
    - 상위 브랜드(Fender) 검색 시 하위 브랜드(Squier) 제외
    - BRAND_HIERARCHY 기반
    
    Returns:
        True = 통과
        False = 탈락
    """
    target_lower = target_brand.lower().strip()
    title_lower = title.lower()
    
    # 브랜드가 없거나 Pending이면 통과
    if not target_lower or 'pending' in target_lower:
        return True
    
    # 핵심 브랜드명 추출 (첫 단어)
    core_brand = target_lower.split()[0] if target_lower else ""
    if not core_brand or len(core_brand) <= 1:
        return True
    
    # 브랜드 하이어라키 검사
    hierarchy = getattr(FilterConfig, 'BRAND_HIERARCHY', {})
    if core_brand in hierarchy:
        for lower_brand in hierarchy[core_brand]:
            if lower_brand in title_lower:
                logger.debug(f"[BrandFilter] 하위 브랜드: '{lower_brand}' - {title[:50]}")
                return False
    
    # 검색 브랜드(또는 한글 별칭)가 제목에 있는지 확인
    aliases = [k for k, v in getattr(CategoryConfig, 'BRAND_NAME_MAPPING', {}).items() if v == core_brand]
    allowed_keywords = [core_brand] + aliases
    
    if any(alias in title_lower for alias in allowed_keywords):
        return True
    
    # 브랜드가 제목에 없으면 탈락
    logger.debug(f"[BrandFilter] 브랜드 불일치: '{core_brand}'(및 별칭 {aliases}) 없음 - {title[:50]}")
    return False


def validate_tokens(model_name: str, title: str) -> bool:
    """
    모델명 토큰 검증.
    - 모델명의 주요 토큰이 제목에 포함되어 있는지 확인
    - 동의어도 확인 (TOKEN_SYNONYMS)
    
    Returns:
        True = 통과 (최소 1개 토큰 매칭)
        False = 탈락
    """
    # Pending 처리
    clean_model = model_name.replace("[Pending] Pending...", "").strip()
    tokens = [t.lower() for t in clean_model.split() if len(t) > 1]
    
    # 토큰이 없으면 통과
    if not tokens:
        return True
    
    title_lower = title.lower()
    synonyms_map = getattr(FilterConfig, 'TOKEN_SYNONYMS', {})
    
    # 모든 토큰 중 하나라도 매칭되면 통과
    for token in tokens:
        # 직접 매칭
        if token in title_lower:
            return True
        # 동의어 매칭
        synonyms = synonyms_map.get(token, [])
        if any(syn in title_lower for syn in synonyms):
            return True
    
    logger.debug(f"토큰 탈락: {tokens} not in '{title[:50]}...'")
    return False


def check_category_mismatch(search_category: str, title: str) -> bool:
    """
    카테고리 불일치 검사.
    - 기타/베이스 검색 시 페달/앰프 제외
    - 페달 검색 시 기타 본체 제외

    Returns:
        True = 통과
        False = 탈락 (불일치)
    """
    title_lower = title.lower()
    search_cat = search_category.lower() if search_category else ""

    # guitar/bass 검색 시
    if search_cat in ['guitar', 'bass']:
        # 페달 제외
        pedal_keywords = getattr(FilterConfig, 'CATEGORY_PEDAL_KEYWORDS', [])
        if any(kw.lower() in title_lower for kw in pedal_keywords):
            logger.debug(f"⛔ 카테고리 탈락: 페달 키워드 in '{title[:50]}...'")
            return False

        # 앰프 제외
        amp_keywords = getattr(FilterConfig, 'CATEGORY_AMP_KEYWORDS', [])
        if any(kw.lower() in title_lower for kw in amp_keywords):
            logger.debug(f"⛔ 카테고리 탈락: 앰프 키워드 in '{title[:50]}...'")
            return False

        # 어쿠스틱 제외 (일렉 위주)
        acoustic_keywords = getattr(FilterConfig, 'CATEGORY_ACOUSTIC_KEYWORDS', [])
        if any(kw.lower() in title_lower for kw in acoustic_keywords):
            logger.debug(f"⛔ 카테고리 탈락: 어쿠스틱 키워드 in '{title[:50]}...'")
            return False

    # acoustic 검색 시
    if search_cat == 'acoustic':
        # 페달/앰프만 제외
        pedal_keywords = getattr(FilterConfig, 'CATEGORY_PEDAL_KEYWORDS', [])
        amp_keywords = getattr(FilterConfig, 'CATEGORY_AMP_KEYWORDS', [])

        if any(kw.lower() in title_lower for kw in pedal_keywords):
            return False
        if any(kw.lower() in title_lower for kw in amp_keywords):
            return False

    # effect(이펙터) 검색 시
    if search_cat == 'effect':
        # "페달", "이펙터" 등이 제목에 있으면 확실히 이펙터이므로 통과
        effect_confirm_keywords = ['pedal', 'effect', 'stomp', '페달', '이펙터', '이펙트']
        if any(kw in title_lower for kw in effect_confirm_keywords):
            return True  # 확실한 이펙터 → 통과

        # 그 외에는 기타 본체 키워드 확인
        instrument_keywords = getattr(FilterConfig, 'CATEGORY_INSTRUMENT_KEYWORDS', [])
        if any(kw.lower() in title_lower for kw in instrument_keywords):
            return False

    # amp 검색 시
    if search_cat == 'amp':
        pedal_keywords = getattr(FilterConfig, 'CATEGORY_PEDAL_KEYWORDS', [])
        if any(kw.lower() in title_lower for kw in pedal_keywords):
            return False

    return True


def check_category_fields(item: dict) -> bool:
    """
    API 응답의 category3, category4 필드 검사.
    액세서리 카테고리면 제외.
    
    Returns:
        True = 통과 (본품)
        False = 탈락 (액세서리/부품)
    """
    category3 = item.get('category3', '').lower()
    category4 = item.get('category4', '').lower()
    
    blacklist = getattr(FilterConfig, 'ACCESSORY_CATEGORY_BLACKLIST', [])
    
    for cat_kw in blacklist:
        cat_kw_lower = cat_kw.lower()
        if cat_kw_lower in category3 or cat_kw_lower in category4:
            logger.debug(f"⛔ 카테고리 필드 탈락: '{cat_kw}' in category3='{category3}' / category4='{category4}'")
            return False
    
    return True


def check_product_type(item: dict) -> bool:
    """
    productType 필드 검사.
    중고(4), 단종(5), 판매예정(6) 제외.
    
    Returns:
        True = 통과
        False = 탈락
    """
    try:
        product_type = int(item.get('productType', 1))
    except (ValueError, TypeError):
        return True  # 파싱 실패시 통과
    
    valid_types = getattr(FilterConfig, 'VALID_PRODUCT_TYPES', [1, 2, 3])
    
    if product_type not in valid_types:
        logger.debug(f"[ProductType] 탈락: {product_type} (허용: {valid_types}) - {item.get('title', '')[:30]}")
        return False
    
    return True


def build_exclusion_query(query: str) -> str:
    """
    쿼리에 제외 키워드를 추가하여 API 레벨에서 액세서리 필터링.
    예: 'BOSS DS-1' -> 'BOSS DS-1 -어댑터 -케이블 -노브'
    
    Returns:
        제외 키워드가 추가된 쿼리 문자열
    """
    exclusion_keywords = getattr(FilterConfig, 'QUERY_EXCLUSION_KEYWORDS', [])
    
    if not exclusion_keywords:
        return query
    
    # 제외 연산자 추가
    exclusions = ' '.join([f'-{kw}' for kw in exclusion_keywords])
    return f'{query} {exclusions}'


def calculate_match_score(query: str, title: str, image_url: str = None) -> int:
    """
    매칭 스코어 계산.
    - 검색어 토큰 매칭률
    - 이미지 유무
    - 중고/신품 구분
    
    Returns:
        0-100 점수
    """
    score = 50  # 기본 점수
    
    query_tokens = [t.lower() for t in query.split() if len(t) > 1]
    title_lower = title.lower()
    
    if not query_tokens:
        return score
    
    # 토큰 매칭률 (최대 +30점)
    matched = sum(1 for t in query_tokens if t in title_lower)
    match_ratio = matched / len(query_tokens)
    score += int(match_ratio * 30)
    
    # 이미지 있으면 +10점
    if image_url and 'http' in str(image_url):
        score += 10
    
    # 중고품이면 +5점 (중고 거래 사이트이므로)
    if '중고' in title_lower or 'used' in title_lower:
        score += 5
    
    # 정품 키워드 있으면 +5점
    if '정품' in title_lower or 'genuine' in title_lower or 'authentic' in title_lower:
        score += 5
    
    return min(score, 100)


def clean_html_tags(text: str) -> str:
    """HTML 태그 및 특수문자 제거"""
    # HTML 태그 제거
    clean = re.sub(r'<[^>]+>', '', text)
    # &nbsp; 등 HTML 엔티티 제거
    clean = clean.replace('\xa0', ' ')
    # 연속 공백 정리
    clean = re.sub(r'\s+', ' ', clean)
    return clean.strip()


def filter_naver_item_with_reason(
    item: dict,
    query: str,
    brand: str = None,
    category: str = None,
    min_price: int = None,
) -> tuple[Optional[dict], str]:
    """
    네이버 쇼핑 아이템 필터링 (탈락 이유 반환).

    Returns:
        (정제된 아이템 또는 None, 탈락 이유)
    """
    title = clean_html_tags(item.get('title', ''))

    try:
        lprice = int(item.get('lprice', 0))
    except (ValueError, TypeError):
        logger.info(f"[Filter] ❌ 가격파싱실패 - {title[:60]}")
        return None, 'price'

    # [필터 1] 최소 가격
    if min_price is None:
        if category == 'effect':
            min_price = CrawlerConfig.MIN_PRICE_PEDAL
        else:
            min_price = CrawlerConfig.MIN_PRICE_KRW

    if not check_min_price(lprice, min_price):
        logger.info(f"[Filter] ❌ 가격미달 {lprice:,}원 < {min_price:,}원 - {title[:60]}")
        return None, 'price'

    # [필터 2] 블랙리스트
    if not check_blacklist(title):
        logger.info(f"[Filter] ❌ 블랙리스트 - {title[:60]}")
        return None, 'blacklist'

    # [필터 3] 브랜드 무결성
    if brand and not check_brand_integrity(brand, title):
        logger.info(f"[Filter] ❌ 브랜드불일치 '{brand}' - {title[:60]}")
        return None, 'brand'

    # [필터 4] 카테고리 불일치
    if category and not check_category_mismatch(category, title):
        cat_info = f"[{item.get('category1', '')}/{item.get('category2', '')}/{item.get('category3', '')}/{item.get('category4', '')}]"
        logger.info(f"[Filter] ❌ 카테고리불일치 '{category}' {cat_info} - {title[:60]}")
        return None, 'category'

    # [필터 5] 카테고리 필드 검사
    if not check_category_fields(item):
        cat_info = f"[{item.get('category1', '')}/{item.get('category2', '')}/{item.get('category3', '')}/{item.get('category4', '')}]"
        logger.info(f"[Filter] ❌ 액세서리카테고리 {cat_info} - {title[:60]}")
        return None, 'category_fields'

    # [필터 6] 상품 타입 검사
    if not check_product_type(item):
        logger.info(f"[Filter] ❌ 상품타입(중고/단종) - {title[:60]}")
        return None, 'product_type'

    # 모든 필터 통과
    image_url = item.get('image', '')
    result = {
        'title': title,
        'link': item.get('link', ''),
        'image': image_url,
        'lprice': lprice,
        'hprice': int(item.get('hprice', 0) or 0),
        'mallName': item.get('mallName', ''),
        'productId': item.get('productId', ''),
        'productType': item.get('productType', 0),
        'brand': item.get('brand', ''),
        'maker': item.get('maker', ''),
        'category1': item.get('category1', ''),
        'category2': item.get('category2', ''),
        'category3': item.get('category3', ''),
        'category4': item.get('category4', ''),
        'source': 'naver',
        'score': calculate_match_score(query, title, image_url),
        'is_used': '중고' in title.lower() or item.get('productType') in [4, 5, 6],
    }
    return result, 'passed'


def filter_naver_item(
    item: dict,
    query: str,
    brand: str = None,
    category: str = None,
    min_price: int = None,
) -> Optional[dict]:
    """
    네이버 쇼핑 아이템 필터링.
    모든 필터를 통과하면 정제된 아이템 반환, 탈락하면 None 반환.
    """
    result, _ = filter_naver_item_with_reason(item, query, brand, category, min_price)
    return result
</file>

<file path="backend/dagu/services.py">
"""
Business logic for MALCHA-DAGU.

- NaverShoppingService: 네이버 쇼핑 API 연동 + 캐싱 + 필터링
- SearchAggregatorService: 네이버 + DB 데이터 병합
- AIDescriptionService: AI 악기 설명 생성
"""

import hashlib
import logging
import re
import concurrent.futures
from difflib import SequenceMatcher
from typing import Any

import requests
from django.conf import settings
from django.core.cache import cache
from django.db import models
from django.utils import timezone

from .models import Instrument, UserItem
from .config import CrawlerConfig
from .filters import (
    filter_naver_item,
    clean_html_tags,
    calculate_match_score,
    check_blacklist,
    check_min_price,
    check_category_fields,
    check_product_type,
    build_exclusion_query,
)

logger = logging.getLogger(__name__)

# =============================================================================
# Constants
# =============================================================================

NAVER_API_URL = 'https://openapi.naver.com/v1/search/shop.json'
CACHE_TTL = 60 * 60  # 1시간 (초 단위)


# =============================================================================
# Naver Shopping API Service
# =============================================================================

class NaverShoppingService:
    """
    네이버 쇼핑 API 연동 서비스.
    Redis 캐싱으로 API 호출 최소화.
    필터링 로직으로 품질 향상.
    """
    
    def __init__(self):
        self.client_id = settings.NAVER_CLIENT_ID
        self.client_secret = settings.NAVER_CLIENT_SECRET
        self.headers = {
            'X-Naver-Client-Id': self.client_id,
            'X-Naver-Client-Secret': self.client_secret,
        }
    
    def _get_cache_key(self, query: str, display: int = 20) -> str:
        """캐시 키 생성 (검색어 해시)"""
        key_base = f"naver_search:{query}:{display}"
        return hashlib.md5(key_base.encode()).hexdigest()
    
    def search(
        self, 
        query: str, 
        display: int = 20, 
        sort: str = 'sim',  # 가격낮은순 (유저 요청 반영)
        brand: str = None,
        category: str = None,
        min_price: int = None,
    ) -> list[dict]:
        """
        네이버 쇼핑 API 검색 + 필터링.
        
        Args:
            query: 검색어
            display: 결과 개수 (최대 100)
            sort: 정렬 (sim: 정확도, date: 날짜, asc: 가격낮은순, dsc: 가격높은순)
            brand: 브랜드 필터 (선택)
            category: 카테고리 필터 (선택)
            min_price: 최소 가격 필터 (선택)
        
        Returns:
            필터링된 검색 결과 리스트
        """
        # 0. 검색어 정규화 (한글 브랜드 -> 영어로 통일하여 캐시 효율성 증대)
        from .config import CategoryConfig
        normalized_query = query
        for kr_name, en_brand in CategoryConfig.BRAND_NAME_MAPPING.items():
            if kr_name in query:
                normalized_query = query.replace(kr_name, en_brand)
                logger.debug(f"[Cache] 검색어 정규화: '{query}' -> '{normalized_query}'")
                break
        
        # 1. 캐시 확인 (정규화된 검색어로 캐시 키 생성)
        cache_key = self._get_cache_key(normalized_query, display * 3)  # 필터링 고려하여 3배 요청
        cached_result = cache.get(cache_key)
        
        raw_items = []
        
        if cached_result is not None:
            logger.debug(f"Cache HIT for query: {query}")
            raw_items = cached_result
        else:
            logger.info(f"📡 Cache MISS - API 호출 시작: {query}")
            
            # 2. API 호출 (API 키가 없으면 빈 리스트 반환)
            if not self.client_id or not self.client_secret:
                logger.warning("⚠️ Naver API credentials not configured")
                return []
            
            try:
                # 제외 키워드 추가 (API 레벨 필터링) - 일단 비활성화
                # enhanced_query = build_exclusion_query(normalized_query)
                enhanced_query = normalized_query  # 정규화된 쿼리 사용
                logger.info(f"네이버 API 검색: '{enhanced_query}'")
                
                # 필터링 대비 넉넉하게 500개 수집 (병렬 처리)
                target_count = 200
                page_size = 100
                starts = range(1, target_count, page_size)  # 1, 101, 201, 301, 401
                
                raw_items = []
                
                # 내부 함수: 단일 페이지 요청
                def fetch_page(start_idx):
                    try:
                        p = {
                            'query': enhanced_query,
                            'display': page_size,
                            'start': start_idx,
                            'sort': sort,
                            'exclude': 'rental',
                        }
                        # logger.debug(f"📤 API 요청 시작: start={start_idx}")
                        res = requests.get(
                            NAVER_API_URL,
                            headers=self.headers,
                            params=p,
                            timeout=CrawlerConfig.TIMEOUT_NAVER,
                        )
                        res.raise_for_status()
                        data = res.json()
                        items = data.get('items', [])
                        # logger.debug(f"📥 API 응답 완료: start={start_idx}, 가져온 개수={len(items)}")
                        return items
                    except Exception as e:
                        logger.error(f"Naver API Error (start={start_idx}): {e}")
                        return []

                # ThreadPoolExecutor로 병렬 실행 (속도 최적화)
                with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
                    logger.info(f"� 병렬 수집 시작: {target_count}개 목표 (Workers=5)")
                    results = executor.map(fetch_page, starts)
                    
                    for items in results:
                        raw_items.extend(items)
                
                logger.info(f"✅ 병렬 수집 완료: 총 {len(raw_items)}개 아이템 확보")
                
                # 캐싱 (원본 데이터)
                cache.set(cache_key, raw_items, CACHE_TTL)
                logger.debug(f"[Cache] 캐싱 완료: {len(raw_items)}개 아이템")
                
            except requests.exceptions.Timeout:
                logger.error(f"Naver API timeout for query: {query}")
                return []
            except requests.exceptions.RequestException as e:
                logger.error(f"Naver API error for query {query}: {e}")
                return []
            except Exception as e:
                logger.exception(f"Unexpected error in Naver API: {e}")
                return []
        
        # 3. 필터링 적용
        filtered_items = []
        stats = {
            'total': 0, 
            'price_fail': 0, 
            'blacklist_fail': 0, 
            'brand_fail': 0, 
            'category_fail': 0,
            'category_field_fail': 0,
            'product_type_fail': 0,
            'passed': 0
        }
        
        logger.debug(f"필터링 시작: {len(raw_items)}개 아이템")

        for item in raw_items:
            stats['total'] += 1
            title = item.get('title', '')[:50]
            logger.debug(f"처리 중: {title}")
            price = int(item.get('lprice', 0) or 0)
            
            # 필터링 함수 호출
            filtered = filter_naver_item(
                item=item,
                query=query,
                brand=brand,
                category=category,
                min_price=min_price,
            )
            
            if filtered:
                stats['passed'] += 1
                filtered_items.append(filtered)
                logger.debug(f"✅ 통과: [{price:,}원] {title}...")
                
                # 목표 개수 달성 시 중단
                if len(filtered_items) >= display:
                    break
            else:
                # 실패 원인 로깅 (DEBUG 레벨)
                logger.debug(f"❌ 탈락: [{price:,}원] {title}...")
        
        # 4. 스코어순 정렬 후 가격순 정렬
        filtered_items.sort(key=lambda x: (-x.get('score', 0), x.get('lprice', 0)))
        
        # 통계 로깅
        logger.info(
            f"📊 [Naver] 필터링 완료: "
            f"원본({stats['total']}) → 통과({stats['passed']}) → 반환({len(filtered_items[:display])})"
        )
        
        # 상위 3개 결과 미리보기
        if filtered_items:
            logger.info("🏆 상위 결과:")
            for i, item in enumerate(filtered_items[:3], 1):
                logger.info(f"   {i}. [{item['lprice']:,}원] {item['title'][:40]}... ({item.get('mallName', 'N/A')})")
        
        return filtered_items[:display]


# =============================================================================
# Search Utilities (검색 유틸리티)
# =============================================================================

def normalize_search_term(term: str) -> str:
    """
    검색어 정규화: 대소문자, 하이픈, 공백 통일
    예: "DS-1", "ds1", "ds 1", "DS 1" → "ds1"
    """
    if not term:
        return ""
    # 소문자 변환
    result = term.lower().strip()
    # 하이픈, 언더스코어, 공백 제거
    result = re.sub(r'[-_\s]+', '', result)
    return result


def expand_query_with_aliases(query: str) -> list[str]:
    """
    검색어를 별칭 매핑으로 확장
    예: "ds1" → ["ds1", "DS-1"]
    """
    from .config import CategoryConfig

    expanded = [query]
    query_lower = query.lower().strip()
    query_normalized = normalize_search_term(query)

    # 별칭 → 정식 모델명 변환
    aliases = getattr(CategoryConfig, 'MODEL_ALIASES', {})

    # 정규화된 검색어로 별칭 찾기
    if query_normalized in aliases:
        expanded.append(aliases[query_normalized])

    # 원본 검색어(소문자)로도 별칭 찾기
    if query_lower in aliases:
        expanded.append(aliases[query_lower])

    # 검색어의 각 토큰별로 별칭 확장
    for token in query_lower.split():
        token_norm = normalize_search_term(token)
        if token_norm in aliases:
            expanded.append(aliases[token_norm])
        if token in aliases:
            expanded.append(aliases[token])

    return list(set(expanded))


def tokenize_query(query: str) -> list[str]:
    """
    검색어를 토큰으로 분리
    예: "boss ds-1" → ["boss", "ds-1", "ds1"]
    """
    tokens = []
    # 공백으로 분리
    words = query.lower().strip().split()
    for word in words:
        tokens.append(word)
        # 하이픈 제거 버전도 추가
        normalized = re.sub(r'[-_]+', '', word)
        if normalized != word:
            tokens.append(normalized)
    return list(set(tokens))


def calculate_instrument_match_score(query: str, instrument) -> float:
    """
    검색어와 악기의 매칭 스코어 계산 (0.0 ~ 1.0)

    높은 점수 조건:
    - 모델명 정확 일치 (예: "ds-1" == "DS-1")
    - 브랜드+모델명 조합 일치
    - 별칭 매칭 (예: "ds1" → "DS-1")
    - 토큰 기반 부분 매칭
    """
    query_normalized = normalize_search_term(query)
    query_tokens = tokenize_query(query)

    # 검색어 별칭 확장 (ds1 → DS-1 등)
    expanded_queries = expand_query_with_aliases(query)

    name = instrument.name or ""
    brand = instrument.brand or ""
    name_normalized = normalize_search_term(name)
    brand_normalized = normalize_search_term(brand)
    full_name = f"{brand} {name}".strip()
    full_normalized = normalize_search_term(full_name)

    score = 0.0

    # 0. 별칭 확장된 쿼리로 정확 매칭 체크
    for expanded in expanded_queries:
        expanded_norm = normalize_search_term(expanded)
        if expanded_norm == name_normalized:
            score = 1.0
            logger.debug(f"[Score 1.0] 별칭 정확 일치: '{expanded}' == '{name}'")
            return score
        # 별칭이 모델명에 포함되어 있는지 확인 (예: "DS-1" in "BOSS DS-1 Distortion")
        if expanded.lower() in name.lower():
            score = 0.95
            logger.debug(f"[Score 0.95] 별칭 포함: '{expanded}' in '{name}'")
            return score

    # 1. 정규화된 모델명 정확 일치 (최고 점수)
    if query_normalized == name_normalized:
        score = 1.0
        logger.debug(f"[Score 1.0] 정확 일치: '{query}' == '{name}'")
        return score

    # 2. 정규화된 전체 이름(브랜드+모델) 정확 일치
    if query_normalized == full_normalized:
        score = 0.95
        logger.debug(f"[Score 0.95] 전체 일치: '{query}' == '{full_name}'")
        return score

    # 3. 모델명이 검색어에 포함 (예: "ds-1" in "boss ds-1")
    if name_normalized and name_normalized in query_normalized:
        score = 0.9
        logger.debug(f"[Score 0.9] 모델명 포함: '{name}' in '{query}'")
        return score

    # 4. 검색어가 모델명에 포함 (예: "ds" in "ds-1")
    if query_normalized and query_normalized in name_normalized:
        base_score = 0.7
        # 길이 비율로 보정 (짧은 검색어 페널티)
        length_ratio = len(query_normalized) / len(name_normalized) if name_normalized else 0
        score = base_score * length_ratio
        logger.debug(f"[Score {score:.2f}] 부분 포함: '{query}' in '{name}'")
        return max(score, 0.3)

    # 5. 토큰 기반 매칭 (별칭 포함)
    matched_tokens = 0
    all_tokens = query_tokens.copy()
    # 별칭 확장된 토큰도 추가
    for expanded in expanded_queries:
        all_tokens.extend(tokenize_query(expanded))
    all_tokens = list(set(all_tokens))

    for token in all_tokens:
        token_norm = normalize_search_term(token)
        if token_norm in name_normalized or token_norm in brand_normalized:
            matched_tokens += 1

    if matched_tokens > 0 and all_tokens:
        token_score = matched_tokens / len(all_tokens)
        score = 0.6 * token_score
        logger.debug(f"[Score {score:.2f}] 토큰 매칭: {matched_tokens}/{len(all_tokens)}")
        return score

    # 6. 유사도 기반 매칭 (SequenceMatcher)
    similarity = SequenceMatcher(None, query_normalized, name_normalized).ratio()
    if similarity > 0.6:
        score = 0.5 * similarity
        logger.debug(f"[Score {score:.2f}] 유사도: {similarity:.2f}")
        return score

    return score


def find_best_matching_instruments(query: str, instruments_qs, min_score: float = 0.3):
    """
    검색어에 가장 잘 맞는 악기들을 스코어 순으로 반환

    Args:
        query: 검색어
        instruments_qs: Instrument QuerySet
        min_score: 최소 스코어 (이하는 제외)

    Returns:
        list of (instrument, score) tuples, sorted by score desc
    """
    scored_instruments = []

    for instrument in instruments_qs:
        score = calculate_instrument_match_score(query, instrument)
        if score >= min_score:
            scored_instruments.append((instrument, score))

    # 스코어 내림차순 정렬
    scored_instruments.sort(key=lambda x: x[1], reverse=True)

    if scored_instruments:
        logger.info(
            f"[매칭 결과] query='{query}' → "
            f"Best: {scored_instruments[0][0].brand} {scored_instruments[0][0].name} "
            f"(score={scored_instruments[0][1]:.2f})"
        )

    return scored_instruments


# =============================================================================
# Search Aggregator Service
# =============================================================================

class SearchAggregatorService:
    """
    네이버 쇼핑 + DB 유저 매물 통합 검색 서비스.
    가격순 정렬로 병합.
    """
    
    def __init__(self):
        self.naver_service = NaverShoppingService()
    
    def _extract_brand_from_query(self, query: str) -> str | None:
        """검색어에서 브랜드 추출 (간단한 휴리스틱)"""
        from .config import CategoryConfig
        
        query_lower = query.lower()
        
        # 알려진 브랜드 목록에서 찾기
        known_brands = CategoryConfig.GUITAR_BRANDS + [
            'boss', 'ibanez', 'jackson', 'charvel', 'schecter', 'suhr',
            'mesa', 'vox', 'marshall', 'orange', 'ampeg', 'tc electronic'
        ]
        
        # 0. 한글 브랜드 매핑 체크
        for kr_name, en_brand in CategoryConfig.BRAND_NAME_MAPPING.items():
            if kr_name in query_lower:
                return en_brand

        for brand in known_brands:
            if brand in query_lower:
                return brand
        
        # 첫 단어를 브랜드로 가정 (2글자 이상)
        first_word = query.split()[0] if query.split() else ""
        if len(first_word) > 2:
            return first_word.lower()
        
        return None
    
    def _detect_category(self, query: str) -> str | None:
        """검색어에서 카테고리 추론"""
        from .config import CategoryConfig
        
        query_lower = query.lower()
        
        if any(kw in query_lower for kw in CategoryConfig.BASS_KEYWORDS):
            return 'BASS'
        if any(kw in query_lower for kw in CategoryConfig.PEDAL_KEYWORDS):
            return 'PEDAL'
        if any(kw in query_lower for kw in CategoryConfig.AMP_KEYWORDS):
            return 'AMP'
        if any(kw in query_lower for kw in CategoryConfig.ACOUSTIC_KEYWORDS):
            return 'ACOUSTIC'
        
        # 기본값은 GUITAR
        return 'GUITAR'
    
    def search(self, query: str, display: int = 20) -> dict[str, Any]:
        """
        통합 검색 수행.
        
        Returns:
            {
                'query': str,
                'total_count': int,
                'reference': { ... },  # 신품 기준가 정보
                'items': [ ... ],      # 가격순 통합 결과
                'naver_items': [ ... ],
                'user_items': [ ... ],
            }
        """
        # 브랜드/카테고리 추출
        brand = self._extract_brand_from_query(query)
        category = self._detect_category(query)
        
        logger.debug(f"query='{query}', brand={brand}, category={category}")
        
        from .config import CategoryConfig
        query_lower = query.lower().strip()
        query_normalized = normalize_search_term(query)

        # =================================================================
        # 1. DB에서 검색어와 매칭되는 악기(Instrument) 찾기
        # - 스마트 매칭: 정규화 + 스코어링 + 별칭 확장
        # - Unknown 브랜드 제외
        # =================================================================

        # 1-1. 후보 악기 조회 (넓게 검색)
        query_tokens = tokenize_query(query)
        expanded_queries = expand_query_with_aliases(query)  # 별칭 확장
        candidate_filter = models.Q()

        # 정규화된 검색어로 이름/브랜드 검색
        for token in query_tokens:
            candidate_filter |= models.Q(name__icontains=token)
            candidate_filter |= models.Q(brand__icontains=token)

        # 별칭 확장된 쿼리로도 검색 (예: ds1 → DS-1)
        for expanded in expanded_queries:
            candidate_filter |= models.Q(name__icontains=expanded)
            # 토큰 분리된 별칭도 검색
            for token in expanded.split():
                if len(token) > 1:
                    candidate_filter |= models.Q(name__icontains=token)

        # 원본 검색어로도 검색 (하이픈 포함 케이스)
        candidate_filter |= models.Q(name__icontains=query_lower)
        candidate_filter |= models.Q(brand__icontains=query_lower)

        logger.debug(f"별칭 확장: {query} → {expanded_queries}")

        candidate_instruments = Instrument.objects.filter(
            candidate_filter
        ).exclude(
            brand__iexact='unknown'
        )[:50]  # 스코어링을 위해 넉넉하게

        logger.debug(f"후보 악기 {candidate_instruments.count()}개 조회됨")

        # 1-2. 스코어링 기반 최적 매칭
        scored_matches = find_best_matching_instruments(
            query=query,
            instruments_qs=candidate_instruments,
            min_score=0.3  # 30% 이상 매칭만 포함
        )

        # 상위 10개만 사용
        matching_instruments = [inst for inst, score in scored_matches[:10]]
        best_match = scored_matches[0] if scored_matches else None

        if best_match:
            logger.info(
                f"[DB 매칭] '{query}' → '{best_match[0].brand} {best_match[0].name}' "
                f"(score={best_match[1]:.2f})"
            )

        # =================================================================
        # 2. 네이버 검색 - 최적 매칭 악기 기준으로 쿼리 생성
        # =================================================================
        naver_items = []
        search_query = query

        if best_match and best_match[1] >= 0.5:  # 50% 이상 매칭일 때만 치환
            best_instrument = best_match[0]
            search_query = f"{best_instrument.brand} {best_instrument.name}"
            brand = best_instrument.brand.lower() if best_instrument.brand else brand
            category = best_instrument.category if best_instrument.category else category
            logger.info(f"[쿼리 변환] '{query}' → '{search_query}'")
        else:
            # 한글 브랜드 -> 영어 브랜드 치환
            for kr_name, en_brand in CategoryConfig.BRAND_NAME_MAPPING.items():
                if kr_name in query:
                    search_query = query.replace(kr_name, en_brand)
                    break
        
        logger.info(f"검색 시작: '{search_query}' (브랜드: {brand}, 카테고리: {category})")
        
        naver_items = self.naver_service.search(
            query=search_query, 
            display=display,
            brand=brand,
            category=category,
        )
        
        # =================================================================
        # 3. DB 유저 매물 검색 - 매칭된 악기에 연결된 UserItem 우선
        # =================================================================
        now = timezone.now()

        if matching_instruments:  # 리스트이므로 len > 0 체크
            # 매칭된 악기들의 UserItem 가져오기
            user_items_qs = UserItem.objects.filter(
                is_active=True,
                expired_at__gt=now,
                instrument__in=matching_instruments
            ).select_related('instrument')[:display]
        else:
            # 매칭 악기 없으면 기존 방식 (제목/브랜드 검색)
            user_items_qs = UserItem.objects.filter(
                is_active=True,
                expired_at__gt=now,
            ).filter(
                models.Q(instrument__name__icontains=query) |
                models.Q(instrument__brand__icontains=query) |
                models.Q(title__icontains=query)
            ).select_related('instrument')[:display]
        
        # 유저 매물을 딕셔너리로 변환 + 필터링
        user_items = []
        reference_info = None
        
        for item in user_items_qs:
            title = item.title or str(item.instrument)
            
            # 블랙리스트 필터
            if not check_blacklist(title):
                continue
            
            # 최소 가격 필터 (유저 매물은 가격 제한 없이 노출)
            # if not check_min_price(item.price):
            #     continue
            
            user_items.append({
                'id': str(item.id),
                'title': title,
                'link': item.link,
                'image': item.instrument.image_url,
                'lprice': item.price,
                'source': item.source,
                'source_display': item.get_source_display(),
                'discount_rate': item.discount_rate,
                'instrument_id': str(item.instrument.id),
                'instrument_name': item.instrument.name,
                'instrument_brand': item.instrument.brand,
                'score': calculate_match_score(query, title, item.instrument.image_url),
            })
            
            # 신품 기준가 정보 (첫 번째 매물 기준)
            if reference_info is None and item.instrument.reference_price > 0:
                reference_info = {
                    'name': str(item.instrument),
                    'price': item.instrument.reference_price,
                    'image_url': item.instrument.image_url,
                }
        
        # 악기 마스터에서도 기준가 검색 (유저 매물이 없을 경우)
        # best_match가 있으면 우선 사용
        if reference_info is None and best_match:
            instrument = best_match[0]
            if instrument.reference_price > 0:
                reference_info = {
                    'name': str(instrument),
                    'price': instrument.reference_price,
                    'image_url': instrument.image_url,
                }

        # 그래도 없으면 DB 검색
        if reference_info is None:
            instrument = Instrument.objects.filter(
                models.Q(name__icontains=query) |
                models.Q(brand__icontains=query)
            ).first()

            if instrument and instrument.reference_price > 0:
                reference_info = {
                    'name': str(instrument),
                    'price': instrument.reference_price,
                    'image_url': instrument.image_url,
                }
        
        # 3. 가격순 병합 정렬
        all_items = naver_items + user_items
        all_items.sort(key=lambda x: x.get('lprice', 0))
        
        logger.info(f"✅ 검색 완료: 네이버({len(naver_items)}) + 유저({len(user_items)}) = 총({len(all_items)})")
        
        return {
            'query': query,
            'total_count': len(all_items),
            'reference': reference_info,
            'items': all_items,
            'naver_items': naver_items,
            'user_items': user_items,
        }


# =============================================================================
# AI Description Service
# =============================================================================

class AIDescriptionService:
    """
    AI 악기 설명 생성 서비스.
    할루시네이션 방지를 위한 프롬프트 엔지니어링 적용.
    """
    
    def __init__(self):
        self.api_key = settings.OPENAI_API_KEY
        self.api_url = 'https://api.openai.com/v1/chat/completions'
    
    def generate_description(
        self, 
        model_name: str, 
        brand: str, 
        category: str
    ) -> dict[str, str]:
        """
        악기 설명 생성 (할루시네이션 방지 적용).
        
        Returns:
            {'summary': str, 'check_point': str}
        """
        if not self.api_key:
            logger.warning("OpenAI API key not configured")
            return {
                'summary': f'{brand} {model_name} - 믿을 수 있는 선택',
                'check_point': '',
            }
        
        # 할루시네이션 방지 프롬프트
        system_prompt = """너는 악기 전문가이자 팩트 체크에 엄격한 에디터다.
사용자가 요청한 악기에 대한 '한 줄 평'과 '구매 가이드'를 작성하라.

# Rules (Strict)
1. **No Hallucination:** Input Data와 너의 지식 베이스가 100% 일치하는 팩트만 서술하라.
   출시 연도나 세부 스펙이 확실하지 않으면 절대 언급하지 말고 톤/음색 특징 위주로 서술하라.
2. **Tone:** "이 악기는~" 처럼 지루하게 시작하지 마라.
   "따뜻한 배음이 매력적입니다", "입문용으로 최고의 선택입니다" 같이 핵심부터 찌르는 간결한 문체를 써라.
3. **Structure:**
   - [summary]: 20자 이내 임팩트 있는 문구.
   - [check_point]: 중고 거래 시 반드시 확인해야 할 고질병(노브 잡음, 넥 휨 등) 1가지. 모르면 빈 문자열.

JSON 형식으로 { "summary": "...", "check_point": "..." } 만 출력하라."""
        
        user_prompt = f"""# Input Data
- 모델명: {model_name}
- 브랜드: {brand}
- 카테고리: {category}"""
        
        try:
            import json
            response = requests.post(
                self.api_url,
                headers={
                    'Authorization': f'Bearer {self.api_key}',
                    'Content-Type': 'application/json',
                },
                json={
                    'model': 'gpt-4o-mini',
                    'messages': [
                        {'role': 'system', 'content': system_prompt},
                        {'role': 'user', 'content': user_prompt},
                    ],
                    'temperature': 0.2,  # 창의성 낮춤 (팩트 위주)
                    'max_tokens': 200,
                },
                timeout=10,
            )
            response.raise_for_status()
            
            data = response.json()
            content = data['choices'][0]['message']['content']
            
            # JSON 파싱
            result = json.loads(content)
            return {
                'summary': result.get('summary', ''),
                'check_point': result.get('check_point', ''),
            }
            
        except Exception as e:
            logger.exception(f"AI description generation error: {e}")
            return {
                'summary': f'{brand} {model_name}',
                'check_point': '',
            }
</file>

<file path="backend/dagu/urls.py">
"""
URL configuration for DAGU app.
"""

from django.urls import include, path
from rest_framework.routers import DefaultRouter

from . import views

# ViewSet router
router = DefaultRouter()
router.register(r'instruments', views.InstrumentViewSet, basename='instrument')
router.register(r'items', views.UserItemViewSet, basename='useritem')

urlpatterns = [
    # Auth Check API (SSO)
    path('auth/check/', views.AuthCheckView.as_view(), name='auth-check'),

    # Search API
    path('search/', views.SearchView.as_view(), name='search'),

    # AI Description API (임시 비활성화)
    # path('ai/describe/', views.AIDescriptionView.as_view(), name='ai-describe'),

    # ViewSet routes
    path('', include(router.urls)),
]
</file>

<file path="backend/dagu/views.py">
"""
API Views for MALCHA-DAGU.
"""

import logging

from django.db import models, transaction

logger = logging.getLogger(__name__)
from django.db.models import F
from django.utils import timezone
from rest_framework import status, viewsets
from rest_framework.decorators import action, api_view
from rest_framework.permissions import AllowAny, IsAdminUser, IsAuthenticatedOrReadOnly
from rest_framework.response import Response
from rest_framework.throttling import ScopedRateThrottle
from rest_framework.views import APIView

from .models import Instrument, UserItem
from .serializers import (
    AIDescriptionRequestSerializer,
    AIDescriptionResponseSerializer,
    InstrumentSerializer,
    SearchResultSerializer,
    UserItemCreateSerializer,
    UserItemSerializer,
)
from .services import SearchAggregatorService
# from .services import AIDescriptionService  # 임시 비활성화


# =============================================================================
# Auth Check API (SSO)
# =============================================================================

class AuthCheckView(APIView):
    """
    SSO 인증 상태 확인 API.
    HttpOnly 쿠키는 JS에서 읽을 수 없으므로, 서버에서 확인.

    GET /api/auth/check/
    """
    permission_classes = [AllowAny]

    def get(self, request):
        if request.user and request.user.is_authenticated:
            return Response({
                'is_authenticated': True,
                'user_id': request.user.id,
                'username': request.user.username,
            })
        return Response({
            'is_authenticated': False,
        })


# =============================================================================
# Search API
# =============================================================================

class SearchView(APIView):
    """
    통합 검색 API.
    네이버 쇼핑 + DB 유저 매물을 가격순으로 병합.

    GET /api/search/?q={검색어}&display={개수}
    """
    permission_classes = [AllowAny]  # 인증 없이 검색 가능
    throttle_classes = [ScopedRateThrottle]
    throttle_scope = 'search'

    def get(self, request):
        query = request.query_params.get('q', '').strip()

        if not query:
            return Response(
                {'error': '검색어를 입력해주세요.'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # 검색어 길이 제한 (XSS/Injection 방지)
        if len(query) > 200:
            return Response(
                {'error': '검색어는 200자 이하로 입력해주세요.'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # display 파라미터 검증
        try:
            display = int(request.query_params.get('display', 20))
        except (ValueError, TypeError):
            display = 20
        display = min(max(display, 1), 100)  # 1~100 범위 제한

        # 통합 검색 수행
        try:
            service = SearchAggregatorService()
            result = service.search(query, display)
        except Exception as e:
            logger.exception(f"Search error for query '{query}': {e}")
            return Response(
                {'error': '검색 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.'},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

        serializer = SearchResultSerializer(result)
        return Response(serializer.data)


# =============================================================================
# Instrument ViewSet (CRUD)
# =============================================================================

class InstrumentViewSet(viewsets.ModelViewSet):
    """
    악기 마스터 CRUD API.

    GET    /api/instruments/          - 목록 (모두 허용)
    POST   /api/instruments/          - 생성 (관리자만)
    GET    /api/instruments/{id}/     - 상세 (모두 허용)
    PUT    /api/instruments/{id}/     - 수정 (관리자만)
    DELETE /api/instruments/{id}/     - 삭제 (관리자만)
    """
    queryset = Instrument.objects.all()
    serializer_class = InstrumentSerializer
    permission_classes = [IsAuthenticatedOrReadOnly]

    def get_permissions(self):
        """액션별 권한 분기"""
        if self.action in ['create', 'update', 'partial_update', 'destroy']:
            return [IsAdminUser()]
        return [AllowAny()]
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # 필터링 옵션
        brand = self.request.query_params.get('brand')
        category = self.request.query_params.get('category')
        search = self.request.query_params.get('search')
        
        if brand:
            queryset = queryset.filter(brand__icontains=brand)
        if category:
            queryset = queryset.filter(category=category)
        if search:
            queryset = queryset.filter(
                models.Q(name__icontains=search) |
                models.Q(brand__icontains=search)
            )
        
        return queryset


# =============================================================================
# UserItem ViewSet (CRUD + Click Tracking)
# =============================================================================

class UserItemViewSet(viewsets.ModelViewSet):
    """
    유저 매물 CRUD API.

    GET    /api/items/              - 목록 (모두 허용)
    POST   /api/items/              - 생성 (로그인 필수)
    GET    /api/items/{id}/         - 상세 (모두 허용)
    PUT    /api/items/{id}/         - 수정 (로그인 필수)
    DELETE /api/items/{id}/         - 삭제 (로그인 필수)
    POST   /api/items/{id}/click/   - 클릭 추적 (모두 허용)
    """

    queryset = UserItem.objects.filter(is_active=True)

    def get_permissions(self):
        """액션별 권한 분기"""
        if self.action in ['create', 'update', 'partial_update', 'destroy']:
            from rest_framework.permissions import IsAuthenticated
            return [IsAuthenticated()]
        return [AllowAny()]
    
    def get_serializer_class(self):
        if self.action == 'create':
            return UserItemCreateSerializer
        return UserItemSerializer
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # 만료된 항목 제외
        now = timezone.now()
        queryset = queryset.filter(expired_at__gt=now)
        
        # 필터링 옵션
        instrument_id = self.request.query_params.get('instrument')
        source = self.request.query_params.get('source')
        min_price = self.request.query_params.get('min_price')
        max_price = self.request.query_params.get('max_price')
        
        if instrument_id:
            queryset = queryset.filter(instrument_id=instrument_id)
        if source:
            queryset = queryset.filter(source=source)
        if min_price:
            try:
                min_price_int = int(min_price)
                if min_price_int < 0:
                    raise ValueError("min_price must be positive")
                queryset = queryset.filter(price__gte=min_price_int)
            except (ValueError, TypeError):
                from rest_framework.exceptions import ValidationError
                raise ValidationError({'min_price': f'유효하지 않은 값: {min_price}'})
        if max_price:
            try:
                max_price_int = int(max_price)
                if max_price_int < 0:
                    raise ValueError("max_price must be positive")
                queryset = queryset.filter(price__lte=max_price_int)
            except (ValueError, TypeError):
                from rest_framework.exceptions import ValidationError
                raise ValidationError({'max_price': f'유효하지 않은 값: {max_price}'})
        
        return queryset.select_related('instrument')

    def create(self, request, *args, **kwargs):
        logger.debug(f"UserItemViewSet.create called with data: {request.data}")
        response = super().create(request, *args, **kwargs)
        logger.debug(f"create success, response: {response.data}")
        return response

    def perform_create(self, serializer):
        """
        매물 생성 시 악기 정보를 자동으로 연결합니다.
        - 트랜잭션으로 원자성 보장
        - 링크 중복 체크
        - 브랜드/카테고리 자동 추출
        - 브랜드를 이름에서 분리 (BOSS DS-1 → brand: BOSS, name: DS-1)
        """
        import re
        from rest_framework.exceptions import ValidationError
        from .services.utils import extract_brand, detect_category

        title = serializer.validated_data.get('title', '').strip()
        link = serializer.validated_data.get('link', '').strip()
        brand = (extract_brand(title) or 'Unknown').upper()
        category = detect_category(title)

        # 브랜드를 이름에서 제거 (BOSS DS-1 → DS-1)
        if brand != 'UNKNOWN':
            # 대소문자 무시하고 브랜드 제거
            name = re.sub(rf'^{re.escape(brand)}\s*', '', title, flags=re.IGNORECASE).strip()
            if not name:  # 브랜드만 있는 경우 원본 유지
                name = title
        else:
            name = title

        # 링크 중복 체크 (활성 매물 중)
        if UserItem.objects.filter(link=link, is_active=True).exists():
            raise ValidationError({'link': '이미 등록된 매물입니다.'})

        with transaction.atomic():
            # select_for_update로 race condition 방지
            instrument = Instrument.objects.select_for_update().filter(
                name__iexact=name,
                brand__iexact=brand
            ).first()

            if not instrument:
                # Unknown 브랜드 악기 업데이트 또는 새로 생성
                instrument = Instrument.objects.select_for_update().filter(
                    name__iexact=name
                ).first()

                if instrument and instrument.brand == 'Unknown' and brand != 'UNKNOWN':
                    instrument.brand = brand
                    if instrument.category == 'other':
                        instrument.category = category
                    instrument.save(update_fields=['brand', 'category'])
                elif not instrument:
                    instrument = Instrument.objects.create(
                        name=name,
                        brand=brand,
                        category=category
                    )

            # owner_id 저장 (JWT user_id)
            owner_id = self.request.user.id if self.request.user.is_authenticated else None
            serializer.save(instrument=instrument, owner_id=owner_id)

    @action(detail=True, methods=['post'])
    def extend(self, request, pk=None):
        """
        유효기간 연장 API (본인 매물만)
        - JWT user_id로 소유자 검증
        - expired_at 72시간 연장
        - extended_at 기록 (우선순위용)
        """
        item = self.get_object()

        # 소유자 검증 (JWT user_id vs owner_id)
        if not request.user.is_authenticated or item.owner_id != request.user.id:
            return Response(
                {'error': '본인 매물만 연장 가능합니다.'},
                status=status.HTTP_403_FORBIDDEN
            )

        with transaction.atomic():
            item.expired_at = timezone.now() + timezone.timedelta(hours=72)
            item.extended_at = timezone.now()
            item.save(update_fields=['expired_at', 'extended_at'])

        serializer = self.get_serializer(item)
        return Response(serializer.data)

    @action(detail=True, methods=['post'])
    def click(self, request, pk=None):
        """
        클릭 추적 API.
        - click_count 증가 (Atomic Update로 동시성 문제 방지)
        - expired_at 12시간 연장
        """
        item = self.get_object()
        
        with transaction.atomic():
            # Atomic update로 click_count 증가
            UserItem.objects.filter(pk=pk).update(
                click_count=F('click_count') + 1,
                expired_at=timezone.now() + timezone.timedelta(hours=12),
            )
        
        # 갱신된 데이터 반환
        item.refresh_from_db()
        serializer = self.get_serializer(item)
        return Response(serializer.data)


# =============================================================================
# AI Description API (임시 비활성화)
# =============================================================================

# class AIDescriptionView(APIView):
#     """
#     AI 악기 설명 생성 API.
#     할루시네이션 방지 프롬프트 적용.
#
#     POST /api/ai/describe/
#     {
#         "model_name": "DS-1",
#         "brand": "BOSS",
#         "category": "effect"
#     }
#     """
#
#     def post(self, request):
#         serializer = AIDescriptionRequestSerializer(data=request.data)
#         serializer.is_valid(raise_exception=True)
#
#         data = serializer.validated_data
#
#         service = AIDescriptionService()
#         result = service.generate_description(
#             model_name=data['model_name'],
#             brand=data['brand'],
#             category=data['category'],
#         )
#
#         response_serializer = AIDescriptionResponseSerializer(result)
#         return Response(response_serializer.data)
</file>

<file path="backend/Dockerfile">
# Backend Dockerfile
FROM python:3.11-slim

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PIP_NO_CACHE_DIR=1

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt .
RUN pip install --upgrade pip && \
    pip install -r requirements.txt

# Copy project
COPY . .

# Collect static files
RUN python manage.py collectstatic --noinput || true

# Run with gunicorn
CMD ["gunicorn", "--bind", "0.0.0.0:8001", "--workers", "2", "config.wsgi:application"]
</file>

<file path="backend/requirements.txt">
# Django
Django>=4.2,<5.0
djangorestframework>=3.14
djangorestframework-simplejwt>=5.3
django-cors-headers>=4.3
django-environ>=0.11
psycopg2-binary>=2.9
redis>=5.0
django-redis>=5.4
celery>=5.3
django-celery-beat>=2.5
requests>=2.31
gunicorn>=21.2
</file>

<file path="frontend/nginx.conf">
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    # Gzip compression
    gzip on;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml;

    # SPA fallback
    location / {
        try_files $uri $uri/ /index.html;
    }

    # API proxy
    location /api/ {
        proxy_pass http://backend:8001;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Cache static assets
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
</file>

<file path="frontend/src/components/ItemCard.tsx">
/**
 * Item Card Component
 * 
 * Features:
 * - 가격 및 할인율 표시
 * - 출처 뱃지
 * - Layout 애니메이션 (순위 변경 시)
 * - 클릭 시 링크 이동
 */

import { motion } from 'framer-motion';
import type { NaverItem, MergedUserItem } from '../types';

interface ItemCardProps {
    item: NaverItem | MergedUserItem;
    rank?: number;
    referencePrice?: number;
    onClick?: () => void;
    isOwner?: boolean;
    onExtend?: () => void;
}

// 출처별 스타일
const SOURCE_STYLES: Record<string, { bg: string; text: string; label: string }> = {
    naver: { bg: 'bg-green-100', text: 'text-green-700', label: '네이버' },
    mule: { bg: 'bg-blue-100', text: 'text-blue-700', label: '뮬' },
    bunjang: { bg: 'bg-red-100', text: 'text-red-700', label: '번개장터' },
    joonggonara: { bg: 'bg-green-100', text: 'text-green-700', label: '중고나라' },
    danggn: { bg: 'bg-orange-100', text: 'text-orange-700', label: '당근' },
    other: { bg: 'bg-stone-100', text: 'text-stone-700', label: '기타' },
};

function formatPrice(price: number): string {
    return new Intl.NumberFormat('ko-KR').format(price);
}

function calculateDiscount(price: number, referencePrice: number): number {
    if (referencePrice <= 0) return 0;
    return Math.round((1 - price / referencePrice) * 100);
}

export default function ItemCard({
    item,
    rank,
    referencePrice,
    onClick,
    isOwner,
    onExtend,
}: ItemCardProps) {
    const source = item.source || 'other';
    const sourceStyle = SOURCE_STYLES[source] || SOURCE_STYLES.other;
    const mallName = 'mallName' in item ? item.mallName : ('source_display' in item ? item.source_display : '');

    // 할인율 계산
    const discount = 'discount_rate' in item
        ? item.discount_rate
        : referencePrice
            ? calculateDiscount(item.lprice, referencePrice)
            : 0;

    // 이미지 URL
    const imageUrl = 'image' in item ? item.image : '';

    const handleClick = () => {
        // 외부 링크 열기
        window.open(item.link, '_blank', 'noopener,noreferrer');
        onClick?.();
    };

    const handleExtend = (e: React.MouseEvent) => {
        e.stopPropagation();  // 카드 클릭 이벤트 방지
        onExtend?.();
    };

    return (
        <motion.div
            layout
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            whileHover={{ scale: 1.02, y: -4 }}
            whileTap={{ scale: 0.98 }}
            onClick={handleClick}
            className="
                relative flex gap-4 p-4 bg-white rounded-2xl shadow-sm
                cursor-pointer transition-all duration-300
                border border-stone-100 hover:border-matcha-200
                hover:shadow-[0_8px_30px_rgb(0,0,0,0.04)]
                group
            "
        >
            {/* 순위 뱃지 */}
            {/* 순위 뱃지 (1~3위만 표시) */}
            {rank && rank <= 3 && (
                <div
                    className={`
                        absolute -top-3 -left-3 w-8 h-8 rounded-full
                        flex items-center justify-center text-sm font-bold text-white shadow-lg z-10
                        ${rank === 1 ? 'bg-gradient-to-br from-yellow-400 to-orange-500' :
                            rank === 2 ? 'bg-gradient-to-br from-stone-300 to-stone-400' :
                                'bg-gradient-to-br from-amber-600 to-amber-700'}
                    `}
                >
                    {rank}
                </div>
            )}

            {/* 이미지 */}
            <div className="flex-shrink-0 w-20 h-20 sm:w-24 sm:h-24 rounded-xl overflow-hidden bg-stone-50 border border-stone-100 group-hover:border-matcha-100 transition-colors">
                {imageUrl ? (
                    <img
                        src={imageUrl}
                        alt={item.title}
                        className="w-full h-full object-cover group-hover:scale-110 transition-transform duration-500"
                        loading="lazy"
                        onError={(e) => {
                            (e.target as HTMLImageElement).src = 'https://via.placeholder.com/96?text=No+Image';
                        }}
                    />
                ) : (
                    <div className="w-full h-full flex items-center justify-center text-3xl opacity-50">
                        🎸
                    </div>
                )}
            </div>

            {/* 정보 */}
            <div className="flex-1 min-w-0 flex flex-col justify-between py-1">
                {/* 상단: 제목 + 출처 */}
                <div>
                    <div className="flex items-start gap-2 mb-1.5">
                        <span
                            className={`
                                flex-shrink-0 px-2.5 py-0.5 rounded-full text-[10px] sm:text-xs font-semibold tracking-wide
                                ${sourceStyle.bg} ${sourceStyle.text}
                            `}
                        >
                            {sourceStyle.label}
                        </span>
                    </div>
                    <h3 className="text-sm sm:text-base font-medium text-stone-800 line-clamp-2 leading-snug group-hover:text-matcha-800 transition-colors">
                        {item.title}
                    </h3>
                </div>

                {/* 하단: 가격 + 할인율 */}
                <div className="flex items-end justify-between mt-2">
                    <div>
                        <div className="flex items-baseline gap-1.5">
                            <p className="text-lg sm:text-xl font-bold text-stone-900">
                                {formatPrice(item.lprice)}<span className="text-xs sm:text-sm font-normal text-stone-500 ml-0.5">원</span>
                            </p>
                        </div>

                        {discount > 0 && (
                            <p className="text-xs text-stone-500 mt-0.5">
                                신품 대비 <span className="text-matcha-600 font-bold">{discount}%</span> 저렴
                            </p>
                        )}
                        {/* 출처 & 판매처 & 배송정보 */}
                        <div className="flex items-center gap-2 mb-1 flex-wrap">
                            <span className={`px-2 py-0.5 rounded text-[11px] font-medium ${sourceStyle.bg} ${sourceStyle.text}`}>
                                {sourceStyle.label}
                            </span>
                            {/* 판매처 (네이버만 표시) */}
                            {source === 'naver' && mallName && (
                                <span className="text-xs text-stone-500 font-medium">
                                    {mallName}
                                </span>
                            )}
                            {/* 무료배송 배지 (네이버 아이템에 임의 적용 or 조건부) */}
                            {source === 'naver' && (
                                <span className="px-1.5 py-0.5 rounded bg-stone-100 text-stone-500 text-[10px]">
                                    무료배송
                                </span>
                            )}
                        </div>

                        {/* 가격 disclaimer (네이버 아이템만) */}
                        {source === 'naver' && (
                            <p className="text-[10px] text-stone-400 mt-0.5">
                                * 가격이 변동될 수 있습니다
                            </p>
                        )}
                    </div>

                    {/* 연장 버튼 (본인 매물만) / 화살표 아이콘 */}
                    <div className="flex items-center gap-2">
                        {isOwner && (
                            <button
                                onClick={handleExtend}
                                className="px-3 py-1.5 rounded-full bg-matcha-100 text-matcha-700 text-xs font-semibold hover:bg-matcha-200 transition-colors"
                            >
                                연장
                            </button>
                        )}
                        <div className="w-8 h-8 rounded-full bg-stone-50 flex items-center justify-center text-stone-400 group-hover:bg-matcha-50 group-hover:text-matcha-600 transition-colors">
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M9 5l7 7-7 7" />
                            </svg>
                        </div>
                    </div>
                </div>
            </div>
        </motion.div>
    );
}
</file>

<file path="frontend/src/components/SearchBar.tsx">
/**
 * Search Bar Component
 * 
 * Features:
 * - 모바일 퍼스트 디자인
 * - DB에서 악기 목록 자동완성
 * - 검색 버튼 hover 효과
 */

import { useState, useEffect, useRef, type FormEvent } from 'react';
import { motion, AnimatePresence } from 'framer-motion';

interface SearchBarProps {
    onSearch: (query: string) => void;
    isLoading?: boolean;
    placeholder?: string;
    initialValue?: string;
    showSuggestions?: boolean;
}

interface Instrument {
    id: string;
    brand: string;
    name: string;  // API에서는 'name' 필드 사용
    category: string;
}

export default function SearchBar({
    onSearch,
    isLoading = false,
    placeholder = '악기 이름으로 검색 (예: Fender Stratocaster)',
    initialValue = '',
    showSuggestions = true,
}: SearchBarProps) {
    const [query, setQuery] = useState(initialValue);
    const [isFocused, setIsFocused] = useState(false);
    const [instruments, setInstruments] = useState<Instrument[]>([]);
    const [suggestions, setSuggestions] = useState<Instrument[]>([]);
    const [showDropdown, setShowDropdown] = useState(false);
    const wrapperRef = useRef<HTMLDivElement>(null);

    // DB에서 악기 목록 로드 (최초 1회)
    useEffect(() => {
        async function fetchInstruments() {
            try {
                const res = await fetch('/api/instruments/');
                if (res.ok) {
                    const data = await res.json();
                    // DRF 페이지네이션 응답 처리 (results 배열)
                    const results = data.results || data;
                    setInstruments(Array.isArray(results) ? results : []);
                }
            } catch (error) {
                console.error('악기 목록 로드 실패:', error);
            }
        }
        fetchInstruments();
    }, []);

    // 입력에 따른 추천 필터링
    useEffect(() => {
        if (query.trim().length > 0 && showSuggestions && instruments.length > 0) {
            const queryLower = query.toLowerCase();
            const filtered = instruments.filter(item => {
                const brand = item.brand || '';
                const modelName = item.name || '';
                const fullName = `${brand} ${modelName}`.toLowerCase();
                return fullName.includes(queryLower) ||
                    brand.toLowerCase().includes(queryLower) ||
                    modelName.toLowerCase().includes(queryLower);
            }).slice(0, 6); // 최대 6개
            setSuggestions(filtered);
            setShowDropdown(filtered.length > 0 && isFocused);
        } else {
            setSuggestions([]);
            setShowDropdown(false);
        }
    }, [query, isFocused, showSuggestions, instruments]);

    // 외부 클릭 시 드롭다운 닫기
    useEffect(() => {
        function handleClickOutside(event: MouseEvent) {
            if (wrapperRef.current && !wrapperRef.current.contains(event.target as Node)) {
                setShowDropdown(false);
            }
        }
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

    const handleSubmit = (e: FormEvent) => {
        e.preventDefault();
        if (query.trim()) {
            onSearch(query.trim());
            setShowDropdown(false);
        }
    };

    const handleSuggestionClick = (instrument: Instrument) => {
        const searchTerm = `${instrument.brand} ${instrument.name}`;
        setQuery(searchTerm);
        onSearch(searchTerm);
        setShowDropdown(false);
    };

    // 카테고리별 이모지
    const getCategoryEmoji = (category: string) => {
        switch (category.toLowerCase()) {
            case '일렉기타': case 'guitar': return '🎸';
            case '베이스': case 'bass': return '🎸';
            case '이펙터': case 'pedal': case 'effects': return '🔊';
            case '앰프': case 'amp': return '🔈';
            case '어쿠스틱': case 'acoustic': return '🪕';
            default: return '🎵';
        }
    };

    return (
        <motion.form
            onSubmit={handleSubmit}
            className="w-full max-w-2xl mx-auto"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5 }}
        >
            <div ref={wrapperRef} className="relative">
                <div
                    className={`
                        relative flex items-center gap-2 p-2 rounded-2xl transition-all duration-300
                        ${isFocused
                            ? 'bg-white shadow-lg shadow-matcha-500/20 ring-2 ring-matcha-400'
                            : 'bg-white/80 shadow-md hover:shadow-lg border border-stone-100'
                        }
                    `}
                    style={{ backdropFilter: 'blur(8px)' }}
                >
                    {/* 검색 아이콘 */}
                    <div className={`pl-4 transition-colors duration-300 ${isFocused ? 'text-matcha-500' : 'text-stone-400'}`}>
                        <svg
                            className="w-5 h-5"
                            fill="none"
                            stroke="currentColor"
                            viewBox="0 0 24 24"
                        >
                            <path
                                strokeLinecap="round"
                                strokeLinejoin="round"
                                strokeWidth={2}
                                d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                            />
                        </svg>
                    </div>

                    {/* 입력 필드 */}
                    <input
                        type="text"
                        value={query}
                        onChange={(e) => setQuery(e.target.value)}
                        onFocus={() => setIsFocused(true)}
                        onBlur={() => setTimeout(() => setIsFocused(false), 150)}
                        placeholder={placeholder}
                        disabled={isLoading}
                        autoComplete="off"
                        className="
                            flex-1 py-3 px-2 bg-transparent outline-none
                            text-stone-800 placeholder-stone-400
                            text-base sm:text-lg caret-matcha-500
                        "
                    />

                    {/* 검색 버튼 */}
                    <motion.button
                        type="submit"
                        disabled={isLoading}
                        whileHover={{ scale: 1.02 }}
                        whileTap={{ scale: 0.98 }}
                        className={`
                            px-6 py-3 rounded-xl font-medium text-white
                            transition-all duration-200
                            ${isLoading
                                ? 'bg-stone-300 cursor-not-allowed'
                                : 'bg-gradient-to-r from-matcha-500 to-matcha-600 hover:from-matcha-600 hover:to-matcha-700 shadow-md hover:shadow-lg hover:shadow-matcha-500/30'
                            }
                        `}
                    >
                        {isLoading ? (
                            <motion.div
                                className="w-5 h-5 border-2 border-white/30 border-t-white rounded-full"
                                animate={{ rotate: 360 }}
                                transition={{ duration: 1, repeat: Infinity, ease: 'linear' }}
                            />
                        ) : (
                            <span className="whitespace-nowrap">검색</span>
                        )}
                    </motion.button>
                </div>

                {/* 자동완성 드롭다운 (DB 악기 목록) */}
                <AnimatePresence>
                    {showDropdown && suggestions.length > 0 && (
                        <motion.div
                            initial={{ opacity: 0, y: -10 }}
                            animate={{ opacity: 1, y: 0 }}
                            exit={{ opacity: 0, y: -10 }}
                            transition={{ duration: 0.15 }}
                            className="
                                absolute z-50 w-full mt-2 py-2
                                bg-white rounded-xl shadow-xl border border-stone-100
                                overflow-hidden
                            "
                        >
                            <p className="px-4 py-1 text-[10px] text-stone-400 uppercase tracking-wider">
                                등록된 악기
                            </p>
                            {suggestions.map((instrument) => (
                                <button
                                    key={instrument.id}
                                    type="button"
                                    onClick={() => handleSuggestionClick(instrument)}
                                    className="
                                        w-full px-4 py-3 text-left flex items-center gap-3
                                        hover:bg-matcha-50 transition-colors
                                        text-stone-700 hover:text-matcha-700
                                    "
                                >
                                    <span className="text-lg">{getCategoryEmoji(instrument.category)}</span>
                                    <div className="flex-1">
                                        <p className="font-medium">{instrument.brand} {instrument.name}</p>
                                        <p className="text-xs text-stone-400">{instrument.category}</p>
                                    </div>
                                </button>
                            ))}
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>

            {/* 검색 힌트 */}
            <motion.p
                className="mt-3 text-center text-sm text-stone-500"
                initial={{ opacity: 0 }}
                animate={{ opacity: 0.8 }}
                transition={{ delay: 0.3 }}
            >
                브랜드, 모델명, 또는 카테고리로 검색해보세요
            </motion.p>
        </motion.form>
    );
}
</file>

<file path="frontend/src/pages/HomePage.tsx">
/**
 * Home Page Component
 * 
 * Features:
 * - 히어로 섹션
 * - 검색바
 * - 검색 시 결과 페이지로 이동
 */

import { useNavigate } from 'react-router-dom';
import { motion } from 'framer-motion';
import SearchBar from '../components/SearchBar';

export default function HomePage() {
    const navigate = useNavigate();

    const handleSearch = (query: string) => {
        navigate(`/search?q=${encodeURIComponent(query)}`);
    };

    return (
        <div className="min-h-screen flex flex-col">
            {/* 히어로 섹션 */}
            <main className="flex-1 flex flex-col items-center justify-center px-4 py-16">
                {/* 로고 / 타이틀 */}
                <motion.div
                    className="text-center mb-12"
                    initial={{ opacity: 0, y: -30 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ duration: 0.6 }}
                >
                    <motion.div
                        className="text-7xl mb-4"
                        animate={{
                            y: [0, -10, 0],
                            rotate: [0, -5, 5, 0],
                        }}
                        transition={{
                            duration: 3,
                            repeat: Infinity,
                            ease: 'easeInOut',
                        }}
                    >
                        🍵
                    </motion.div>

                    <h1 className="text-5xl sm:text-6xl font-black mb-4 tracking-tight text-stone-700">
                        DAGU
                    </h1>

                    <p className="text-lg text-stone-600 max-w-md mx-auto">
                        악기 시세를 한눈에 비교하고, <br className="sm:hidden" />
                        <span className="text-emerald-600 font-medium">합리적인 가격</span>에 득템하세요
                    </p>
                </motion.div>

                {/* 검색바 */}
                <div className="w-full max-w-xl px-4 relative z-10">
                    <SearchBar onSearch={handleSearch} />
                </div>

                {/* 인기 검색어 / 빠른 검색 */}
                <motion.div
                    className="mt-12 flex flex-col items-center gap-4"
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    transition={{ delay: 0.5 }}
                >
                    <span className="text-sm font-medium text-stone-400 uppercase tracking-widest text-[11px] mb-2">인기 검색어</span>
                    <div className="flex flex-wrap justify-center gap-2.5">
                        {['Fender Stratocaster', 'Gibson Les Paul', 'BOSS DS-1', 'Ibanez RG'].map((term) => (
                            <motion.button
                                key={term}
                                onClick={() => handleSearch(term)}
                                className="
                                    px-4 py-2 text-sm bg-white/80 backdrop-blur-sm text-stone-600 
                                    rounded-full border border-stone-200 
                                    hover:bg-matcha-50 hover:border-matcha-200 hover:text-matcha-700 
                                    hover:shadow-md transition-all duration-300 shadow-sm
                                    flex items-center gap-1.5
                                "
                                whileHover={{ scale: 1.05, y: -2 }}
                                whileTap={{ scale: 0.95 }}
                            >
                                <span className="opacity-40 text-xs">#</span>
                                {term}
                            </motion.button>
                        ))}
                    </div>
                </motion.div>
            </main>

            {/* 푸터 */}
            <footer className="py-8 text-center text-sm text-stone-400 mt-auto">
                <p>© 2026 MALCHA DAGU. 악기 시세 비교 서비스</p>
            </footer>
        </div>
    );
}
</file>

<file path="frontend/src/pages/SearchResultPage.tsx">
/**
 * Search Result Page Component
 * 
 * Features:
 * - 검색 결과 리스트 (Staggered Animation)
 * - 매물 등록 버튼 (API 연동 + 자동 소스 감지)
 * - React Query 캐싱 및 자동 갱신
 */

import { useState, useEffect } from 'react';
import { useSearchParams, useNavigate } from 'react-router-dom';
import { motion, AnimatePresence } from 'framer-motion';
import { useQueryClient } from '@tanstack/react-query';
import { AxiosError } from 'axios';
import SearchBar from '../components/SearchBar';
import MatchaBounceLoader from '../components/MatchaBounceLoader';
import ItemCard from '../components/ItemCard';
import { useSearch, useTrackItemClick, useCreateUserItem, useExtendUserItem } from '../hooks/useSearch';
import { useAuth } from '../hooks/useAuth';
import type { NaverItem, MergedUserItem } from '../types';

// API 에러 응답 타입
interface ApiErrorResponse {
    [key: string]: string | string[];
}

// 소스 자동 감지 헬퍼
const SOURCE_LABELS: Record<string, string> = {
    mule: '뮬 (Mule)',
    joonggonara: '중고나라',
    danggn: '당근마켓',
    bunjang: '번개장터',
    other: '기타 사이트'
};

const SOURCE_COLORS: Record<string, string> = {
    mule: 'bg-blue-50 text-blue-700 border-blue-200',
    joonggonara: 'bg-green-50 text-green-700 border-green-200',
    danggn: 'bg-orange-50 text-orange-700 border-orange-200',
    bunjang: 'bg-red-50 text-red-700 border-red-200',
    other: 'bg-stone-50 text-stone-600 border-stone-200'
};

function detectSource(url: string): string {
    const lower = url.toLowerCase();
    if (lower.includes('mule.co.kr')) return 'mule';
    if (lower.includes('joonggonara') || (lower.includes('cafe.naver.com') && lower.includes('joon'))) return 'joonggonara';
    if (lower.includes('daangn.com') || lower.includes('danggn')) return 'danggn';
    if (lower.includes('bunjang.co.kr')) return 'bunjang';
    return 'other';
}

const MIN_LOADING_TIME = 1500;

export default function SearchResultPage() {
    const [searchParams] = useSearchParams();
    const navigate = useNavigate();
    const query = searchParams.get('q') || '';

    const [showLoader, setShowLoader] = useState(true);
    const [minTimeElapsed, setMinTimeElapsed] = useState(false);
    const [showRegisterModal, setShowRegisterModal] = useState(false);

    // SSO 인증 상태 확인
    const { isLoggedIn, userId } = useAuth();

    // React Query로 검색
    const { data, isLoading, isError, error } = useSearch(query, {
        enabled: query.length > 0,
    });

    // 클릭 추적
    const trackClick = useTrackItemClick();

    // 연장 기능
    const extendItem = useExtendUserItem();

    // 최소 로딩 시간 보장
    useEffect(() => {
        if (!query) return;
        setShowLoader(true);
        setMinTimeElapsed(false);
        const timer = setTimeout(() => setMinTimeElapsed(true), MIN_LOADING_TIME);
        return () => clearTimeout(timer);
    }, [query]);

    useEffect(() => {
        if (!isLoading && minTimeElapsed) {
            setShowLoader(false);
        }
    }, [isLoading, minTimeElapsed]);

    const handleSearch = (newQuery: string) => {
        navigate(`/search?q=${encodeURIComponent(newQuery)}`);
    };

    const handleItemClick = (item: NaverItem | MergedUserItem) => {
        if ('id' in item && item.source !== 'naver') {
            trackClick.mutate(item.id);
        }
    };

    const handleExtendItem = (itemId: string) => {
        extendItem.mutate(itemId, {
            onSuccess: () => {
                alert('매물이 72시간 연장되었습니다!');
            },
            onError: (err: Error) => {
                alert(`연장 실패: ${err.message}`);
            },
        });
    };

    // 소유자 여부 확인
    const isOwner = (item: NaverItem | MergedUserItem): boolean => {
        if (!isLoggedIn || !userId) return false;
        if (!('owner_id' in item)) return false;
        return item.owner_id === userId;
    };

    if (!query) {
        navigate('/');
        return null;
    }

    const allItems = data?.items || [];

    return (
        <div className="min-h-screen">
            <MatchaBounceLoader isVisible={showLoader} />

            {!showLoader && (
                <motion.div
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    transition={{ duration: 0.4 }}
                >
                    {/* 헤더 */}
                    <header className="sticky top-0 z-40 bg-white/90 backdrop-blur-md border-b border-stone-200 shadow-sm">
                        <div className="max-w-4xl mx-auto px-4 py-4">
                            <div className="flex items-center gap-4">
                                <motion.button
                                    onClick={() => navigate('/')}
                                    className="text-2xl font-black text-matcha-600 tracking-tight"
                                    whileHover={{ scale: 1.05 }}
                                    whileTap={{ scale: 0.95 }}
                                >
                                    DAGU
                                </motion.button>
                                <div className="flex-1">
                                    <SearchBar
                                        onSearch={handleSearch}
                                        isLoading={isLoading}
                                        initialValue={query}
                                        placeholder="다른 악기 검색"
                                    />
                                </div>
                            </div>
                        </div>
                    </header>

                    {/* 메인 */}
                    <main className="max-w-4xl mx-auto px-4 py-8">
                        {/* 헤더 */}
                        <div className="flex items-center justify-between mb-6">
                            <div>
                                <h1 className="text-2xl font-bold text-stone-800">
                                    "<span className="text-matcha-600">{query}</span>" 검색 결과
                                </h1>
                                {data && (
                                    <p className="text-stone-500 mt-1">
                                        {data.total_count}개 매물
                                    </p>
                                )}
                            </div>
                        </div>

                        {/* 에러 */}
                        {isError && (
                            <div className="text-center py-12 bg-red-50 rounded-2xl border border-red-100">
                                <p className="text-4xl mb-4">😵</p>
                                <p className="text-red-700 font-medium">검색 중 오류가 발생했습니다</p>
                                <p className="text-red-500 text-sm mt-2">
                                    {error instanceof Error ? error.message : '잠시 후 다시 시도해주세요'}
                                </p>
                            </div>
                        )}

                        {/* 결과 없음 */}
                        {data && data.total_count === 0 && (
                            <div className="text-center py-16 bg-stone-50 rounded-2xl border border-dashed border-stone-300">
                                <p className="text-4xl mb-4 opacity-50">🎸</p>
                                <p className="text-stone-600 font-medium">검색 결과가 없습니다</p>
                                <p className="text-stone-400 text-sm mt-2">다른 검색어로 시도해보세요</p>
                            </div>
                        )}

                        {/* 결과 리스트 */}
                        {allItems.length > 0 && (
                            <motion.div
                                className="space-y-4"
                                variants={{
                                    hidden: { opacity: 0 },
                                    show: {
                                        opacity: 1,
                                        transition: {
                                            staggerChildren: 0.1
                                        }
                                    }
                                }}
                                initial="hidden"
                                animate="show"
                            >
                                {allItems.map((item, index) => (
                                    <motion.div
                                        key={`item-${index}-${'id' in item ? item.id : item.productId}`}
                                        variants={{
                                            hidden: { opacity: 0, y: 20 },
                                            show: { opacity: 1, y: 0 }
                                        }}
                                    >
                                        <ItemCard
                                            item={item}
                                            rank={index + 1}
                                            referencePrice={data?.reference?.price}
                                            onClick={() => handleItemClick(item)}
                                            isOwner={isOwner(item)}
                                            onExtend={'id' in item ? () => handleExtendItem(item.id) : undefined}
                                        />
                                    </motion.div>
                                ))}
                            </motion.div>
                        )}
                    </main>

                    {/* FAB (매물 등록) - 로그인 시에만 표시 */}
                    {isLoggedIn && (
                        <motion.button
                            onClick={() => setShowRegisterModal(true)}
                            className="
                                fixed bottom-8 right-8 z-50
                                w-14 h-14 rounded-full bg-stone-800 text-white shadow-xl
                                flex items-center justify-center text-2xl font-light
                                hover:bg-stone-900 border border-stone-700
                            "
                            initial={{ scale: 0, rotate: 90 }}
                            animate={{ scale: 1, rotate: 0 }}
                            whileHover={{ scale: 1.1 }}
                            whileTap={{ scale: 0.9 }}
                        >
                            +
                        </motion.button>
                    )}
                </motion.div>
            )}

            {/* 매물 등록 모달 */}
            <AnimatePresence>
                {showRegisterModal && (
                    <RegisterModal
                        query={query}
                        onClose={() => setShowRegisterModal(false)}
                    />
                )}
            </AnimatePresence>
        </div>
    );
}

// 매물 등록 모달
function RegisterModal({ query, onClose }: { query: string; onClose: () => void }) {
    const [price, setPrice] = useState('');
    const [link, setLink] = useState('');
    const [detectedSource, setDetectedSource] = useState('other');

    // 링크 입력 시 소스 감지
    useEffect(() => {
        setDetectedSource(detectSource(link));
    }, [link]);

    // API Hook
    const createUserItem = useCreateUserItem();
    const queryClient = useQueryClient();

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();

        // 1. 링크 URL 보정 (http/https 없으면 추가)
        let finalLink = link.trim();
        if (finalLink && !finalLink.match(/^https?:\/\//)) {
            finalLink = `https://${finalLink}`;
        }

        // 2. 최종 소스 결정
        const finalSource = detectSource(finalLink);

        createUserItem.mutate({
            title: query,
            price: Number(price),
            link: finalLink,
            source: finalSource
        }, {
            onSuccess: () => {
                // 검색 결과 캐시 즉시 만료 및 갱신 요청
                queryClient.invalidateQueries({ queryKey: ['search'] });

                const sourceName = SOURCE_LABELS[finalSource] || '등록된 매물';
                alert(`${sourceName} 매물이 성공적으로 등록되었습니다! 🎸`);
                onClose();
            },
            onError: (error: AxiosError<ApiErrorResponse>) => {
                console.error('Failed to register item:', error);

                let errorMsg = '등록에 실패했습니다.';
                try {
                    const data = error.response?.data;
                    if (data) {
                        // JSON 문자열로 변환 후 파싱
                        const jsonStr = JSON.stringify(data);
                        if (jsonStr.includes('이미 등록된')) {
                            errorMsg = '이미 등록된 매물입니다.';
                        } else {
                            // 모든 에러 메시지 추출
                            const messages: string[] = [];
                            Object.values(data).forEach(value => {
                                if (Array.isArray(value)) {
                                    messages.push(...value.map(v => String(v)));
                                } else if (typeof value === 'string') {
                                    messages.push(value);
                                }
                            });
                            errorMsg = messages.join('\n') || '입력값을 확인해주세요.';
                        }
                    }
                } catch {
                    errorMsg = error.message || '등록에 실패했습니다.';
                }
                alert(errorMsg);
            }
        });
    };

    return (
        <motion.div
            className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={onClose}
        >
            <motion.div
                className="w-full max-w-md bg-white rounded-2xl shadow-2xl p-6"
                initial={{ scale: 0.9, y: 20 }}
                animate={{ scale: 1, y: 0 }}
                exit={{ scale: 0.9, y: 20 }}
                onClick={(e) => e.stopPropagation()}
            >
                <div className="flex items-center justify-between mb-4">
                    <h2 className="text-xl font-bold text-stone-800">매물 등록</h2>
                    <button
                        onClick={onClose}
                        className="w-8 h-8 rounded-full bg-stone-100 flex items-center justify-center text-stone-500 hover:bg-stone-200"
                    >
                        ✕
                    </button>
                </div>

                {/* 악기명 표시 (자동) */}
                <div className="mb-4 p-3 bg-matcha-50 rounded-xl border border-matcha-100">
                    <p className="text-xs text-matcha-600 font-medium mb-1">악기명</p>
                    <p className="text-lg font-bold text-matcha-800">{query}</p>
                </div>

                <form onSubmit={handleSubmit} className="space-y-4">
                    {/* 가격 */}
                    <div>
                        <label className="block text-sm font-medium text-stone-700 mb-1.5">
                            가격 (원)
                        </label>
                        <input
                            type="number"
                            value={price}
                            onChange={(e) => setPrice(e.target.value)}
                            className="w-full px-4 py-3 rounded-xl border border-stone-200 focus:border-matcha-400 focus:ring-2 focus:ring-matcha-100 outline-none transition-all"
                            placeholder="예: 850000"
                            required
                        />
                    </div>

                    {/* 링크 */}
                    <div>
                        <label className="block text-sm font-medium text-stone-700 mb-1.5">
                            매물 링크
                        </label>
                        <input
                            type="text"
                            value={link}
                            onChange={(e) => setLink(e.target.value)}
                            className="w-full px-4 py-3 rounded-xl border border-stone-200 focus:border-matcha-400 focus:ring-2 focus:ring-matcha-100 outline-none transition-all"
                            placeholder="예: mule.co.kr/..."
                            required
                        />

                        {/* URL 감지 결과 표시 */}
                        {link.length > 5 && (
                            <motion.div
                                initial={{ opacity: 0, y: -5 }}
                                animate={{ opacity: 1, y: 0 }}
                                className={`mt-2 flex items-center gap-2 text-sm p-3 rounded-xl border ${SOURCE_COLORS[detectedSource]}`}
                            >
                                <span className="text-lg">
                                    {detectedSource === 'other' ? '🔗' : '✅'}
                                </span>
                                <span className="font-bold">
                                    {detectedSource === 'other'
                                        ? '출처를 감지할 수 없습니다 (기타로 등록됩니다)'
                                        : `${SOURCE_LABELS[detectedSource]} 감지되었습니다!`}
                                </span>
                            </motion.div>
                        )}
                    </div>

                    {/* 버튼 */}
                    <div className="flex gap-3 pt-2">
                        <button
                            type="button"
                            onClick={onClose}
                            className="flex-1 py-3 rounded-xl border border-stone-200 text-stone-600 font-medium hover:bg-stone-50 transition-colors"
                        >
                            취소
                        </button>
                        <button
                            type="submit"
                            disabled={createUserItem.isPending}
                            className={`flex-1 py-3 rounded-xl text-white font-bold transition-all shadow-md active:scale-95 disabled:opacity-50 ${detectedSource !== 'other'
                                ? 'bg-matcha-600 hover:bg-matcha-700 hover:shadow-lg'
                                : 'bg-stone-500 hover:bg-stone-600'
                                }`}
                        >
                            {createUserItem.isPending ? '등록 중...' : '등록하기'}
                        </button>
                    </div>
                </form>
            </motion.div>
        </motion.div>
    );
}
</file>

<file path="frontend/src/services/api.ts">
/**
 * API client for MALCHA-DAGU backend
 */

import axios from 'axios';
import type { SearchResult, Instrument, UserItem, AIDescription } from '../types';

const api = axios.create({
    baseURL: '/api',
    headers: {
        'Content-Type': 'application/json',
    },
    withCredentials: true,  // SSO 쿠키 전송 필수
});

// =============================================================================
// Search API
// =============================================================================

export async function search(query: string, display = 20): Promise<SearchResult> {
    const response = await api.get<SearchResult>('/search/', {
        params: { q: query, display },
    });
    return response.data;
}

// =============================================================================
// Instrument API
// =============================================================================

export async function getInstruments(params?: {
    brand?: string;
    category?: string;
    search?: string;
}): Promise<Instrument[]> {
    const response = await api.get<{ results: Instrument[] }>('/instruments/', { params });
    return response.data.results || response.data as unknown as Instrument[];
}

export async function getInstrument(id: string): Promise<Instrument> {
    const response = await api.get<Instrument>(`/instruments/${id}/`);
    return response.data;
}

// =============================================================================
// UserItem API
// =============================================================================

export async function getUserItems(params?: {
    instrument?: string;
    source?: string;
    min_price?: number;
    max_price?: number;
}): Promise<UserItem[]> {
    const response = await api.get<{ results: UserItem[] }>('/items/', { params });
    return response.data.results || response.data as unknown as UserItem[];
}

export async function createUserItem(data: {
    instrument?: string;
    price: number;
    link: string;
    source: string;
    title?: string;
}): Promise<UserItem> {
    // instrument가 없거나 빈 문자열이면 제거
    const payload = { ...data };
    if (!payload.instrument) {
        delete payload.instrument;
    }
    const response = await api.post<UserItem>('/items/', payload);
    return response.data;
}

export async function trackItemClick(id: string): Promise<UserItem> {
    const response = await api.post<UserItem>(`/items/${id}/click/`);
    return response.data;
}

export async function extendUserItem(id: string): Promise<UserItem> {
    const response = await api.post<UserItem>(`/items/${id}/extend/`);
    return response.data;
}

// =============================================================================
// AI Description API
// =============================================================================

export async function getAIDescription(data: {
    model_name: string;
    brand: string;
    category: string;
}): Promise<AIDescription> {
    const response = await api.post<AIDescription>('/ai/describe/', data);
    return response.data;
}

export default api;
</file>

<file path="frontend/vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    react(),
    tailwindcss(),
  ],
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8001',
        changeOrigin: true,
      },
    },
  },
})
</file>

</files>
